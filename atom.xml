<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuangWei&#39;s blog</title>
  
  <subtitle>That depends a good deal on where you want to get to</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangwei.pro/"/>
  <updated>2016-04-14T08:48:03.562Z</updated>
  <id>http://huangwei.pro/</id>
  
  <author>
    <name>HuangWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang笔记</title>
    <link href="http://huangwei.pro/2016-03/golang-note1/"/>
    <id>http://huangwei.pro/2016-03/golang-note1/</id>
    <published>2016-03-01T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.562Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>整理的有点乱，都是开发中遇到的问题和网上看到好文章的记录，作为知识点保存下。</p><h2 id="Array和Slice"><a href="#Array和Slice" class="headerlink" title="Array和Slice"></a>Array和Slice</h2><h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化<i class="fa fa-star"></i></h3><p><a href="https://golang.org/ref/spec#Array_types" target="_blank" rel="noopener">Array定义</a>:</p><blockquote><p>ArrayType   = “[“ ArrayLength “]” ElementType .</p><p>ArrayLength = Expression .</p><p>ElementType = Type .</p></blockquote><p>在 Go 语言中数组是<strong>固定长度</strong>的数据类型。一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p><a id="more"></a><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为5的整数数组</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个长度为5的整数数组</span></span><br><span class="line"><span class="comment">// 初始化每个元素</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">77</span>, <span class="number">777</span>, <span class="number">7777</span>, <span class="number">77777</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化值的个数来推导出数组容量, ...在这里表示自动推导</span></span><br><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">77</span>, <span class="number">777</span>, <span class="number">7777</span>, <span class="number">77777</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个长度为5的整数数组</span></span><br><span class="line"><span class="comment">// 为索引为1和2的位置指定元素初始化</span></span><br><span class="line"><span class="comment">// 剩余元素为0值</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">77</span>, <span class="number">2</span>: <span class="number">777</span>&#125;</span><br></pre></td></tr></table></figure><p><a href="https://golang.org/ref/spec#Slice_types" target="_blank" rel="noopener">Slice定义</a>:</p><blockquote><p>SliceType = “[“ “]” ElementType .</p></blockquote><p>slice 是一种可以<strong>动态数组</strong>，可以按我们的希望增长和收缩。它跟Array声明的区别就在于<code>[]</code>里面是空的。两者在机制上的区别，Array更像是块线性存储区，Slice像Array的引用并加上长度和容量的管理。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度和容量都是 5的slice</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个有100个元素的空的字符串 slice</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="number">99</span>: <span class="string">""</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个容量为5，长度为3的slice</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="nil-和-empty"><a href="#nil-和-empty" class="headerlink" title="nil 和 empty"></a>nil 和 empty</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光声明，不初始化，slice就是nil</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用make或字面值创建，slice是empty的</span></span><br><span class="line">silce := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不管我们用 nil slice 还是 empty slice，内建函数 <code>append</code>，<code>len</code>和<code>cap</code>的工作方式完全相同。</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>如果slice的所引用的存储区容量够大，返回的slice就是本身。如果容量不够，Go底层会新分配一块存储区，并复制和添加相关数据到新存储区。所以<code>append</code>后一定要使用它的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</span><br></pre></td></tr></table></figure><p>特殊得，byte slice添加string也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...)</span><br></pre></td></tr></table></figure><p>注意string后面的<code>...</code>，相当与是对string的解包，相关的概念在Python和Lua等动态型语言里也有。</p><h4 id="存储机制理解"><a href="#存储机制理解" class="headerlink" title="存储机制理解"></a>存储机制理解</h4><p>看这么几个图就明白了。</p><p>Array结构</p><p><img src="http://blog.golang.org/go-slices-usage-and-internals_slice-array.png" alt="Array"></p><p>Slice结构</p><p><img src="http://blog.golang.org/go-slices-usage-and-internals_slice-struct.png" alt="Slice Struct"></p><p>Slice表示</p><p><img src="http://blog.golang.org/go-slices-usage-and-internals_slice-1.png" alt="Slice"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">b := a[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">fmt.Println(a) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [1]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [1 2 0 0 0] a和b是同个存储区</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [3]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [3 2 0 0 0] a和b是同个存储区</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">4</span>)</span><br><span class="line">fmt.Println(b) <span class="comment">// [3 2 0 0 0 4] b新建存储区</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [3]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [5 2 0 0 0 4] 从此a和b是路人</span></span><br></pre></td></tr></table></figure><p><a href="http://dwz.cn/2Pcjro" target="_blank" rel="noopener">http://dwz.cn/2Pcjro</a></p><h3 id="函数传递"><a href="#函数传递" class="headerlink" title="函数传递"></a>函数传递<i class="fa fa-star"></i></h3><p>Array作为固定长度的存储区，作为参数传递时，它的行为代价是昂贵的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span></span><br><span class="line">foo(array)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array [1e6]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次 <code>foo</code> 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p><p>当然可以传指针来解决这个问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span></span><br><span class="line">foo(&amp;array)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(array *[1e6]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但你在函数中改变指针指向的值，那么原始数组的值也会被改变。</p><p>而传递Slice是很廉价的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(unsafe.Sizeof([]<span class="keyword">int</span>&#123;&#125;)) <span class="comment">// size 24</span></span><br></pre></td></tr></table></figure><p>深度阅读参考：</p><ol><li><a href="http://blog.golang.org/slices" target="_blank" rel="noopener">Arrays, slices (and strings): The mechanics of ‘append’</a></li><li><a href="http://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="noopener">Go Slices: usage and internals</a></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化<i class="fa fa-star"></i></h3><p>map 是一种<strong>无序</strong>的键值对的集合。 map 是使用 hash 表来实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 make 来创建</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面值创建</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"Red"</span>: <span class="string">"#da1337"</span>, <span class="string">"Orange"</span>: <span class="string">"#e95a22"</span>&#125;</span><br></pre></td></tr></table></figure><p>使用字面值是创建 map 惯用的方法。</p><h3 id="键值比较"><a href="#键值比较" class="headerlink" title="键值比较"></a>键值比较<i class="fa fa-star"></i><i class="fa fa-star"></i></h3><p>C++的<code>std::map</code>支持自定义类型作为键值，只要重载<code>operator&lt;</code>即可。在Go里也有类似概念，但Go没有操作符重载，并且map用hash实现的，所以键值比较是靠<code>==</code>操作符。</p><p>除了内建类型，struct类型的<code>==</code>比较是逐个比较相应字段，只要相应字段都可比较那struct也就是可比较的。如slice，function是不可比较的，那包含 slice 的 struct 类型也不可以作为 map 的键，否则会编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[[]<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">Compiler Exception:</span><br><span class="line">invalid <span class="keyword">map</span> key <span class="keyword">type</span> []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h2 id="struct-用途"><a href="#struct-用途" class="headerlink" title="struct{}用途"></a>struct{}用途<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></h2><p>参考<a href="http://dave.cheney.net/2014/03/25/the-empty-struct" target="_blank" rel="noopener">The empty struct</a>里的说明。</p><p>比如Go没有内置Set实现，我们会用map来模拟，那<code>map[int]bool</code>和<code>map[int]struct{}</code>哪个好？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = s</span><br><span class="line">fmt.Println(unsafe.Sizeof(b)) <span class="comment">// prints 1</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(s)) <span class="comment">// prints 0</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(i)) <span class="comment">// prints 16</span></span><br></pre></td></tr></table></figure><p><a href="http://dwz.cn/2PcWLF" target="_blank" rel="noopener">http://dwz.cn/2PcWLF</a></p><p>基于上述struct{}对内存友好，优于<code>bool</code>和<code>interface{}</code>，我们可以优雅的实现Set。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> empty Empty</span><br><span class="line"></span><br><span class="line">mm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]Empty)</span><br><span class="line">mm[<span class="number">1</span>] = empty</span><br></pre></td></tr></table></figure><p>另外，类似的还有，channel用来传递信号可以定义为<code>chan struct {}</code></p><p>请注意struct{}有这么一个坑，结果和直觉有点不符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(&amp;a == &amp;b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line">fmt.Println(&amp;a == &amp;b)       <span class="comment">// false, a and b are different slices</span></span><br><span class="line">fmt.Println(&amp;a[<span class="number">0</span>] == &amp;b[<span class="number">0</span>]) <span class="comment">// true, their backing arrays are the same</span></span><br></pre></td></tr></table></figure><h2 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual"></a>reflect.DeepEqual<i class="fa fa-star"></i><i class="fa fa-star"></i></h2><p>如果有两个map，内容都一样，只有顺序不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>&#125;;</span><br><span class="line">m2:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"c"</span>:<span class="number">3</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们怎么判断二者是否一致呢？</p><p>如果你打算这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"m1==m2"</span>,m1==m2)</span><br></pre></td></tr></table></figure><p>这是行不通的，Go没有重写map的==操作符，编译器会报告错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: m1 == m2 (<span class="keyword">map</span> can only be compared to <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>Go的反射包中有一个巨好用的武器reflect.DeepEqual,可以方便解决这个问题。</p><p><a href="http://dwz.cn/2PdMHG" target="_blank" rel="noopener">http://dwz.cn/2PdMHG</a></p><p>持续更新中ing…</p>]]></content>
    
    <summary type="html">
    
      Golang笔记
    
    </summary>
    
      <category term="go" scheme="http://huangwei.pro/categories/go/"/>
    
    
      <category term="dev-log" scheme="http://huangwei.pro/tags/dev-log/"/>
    
      <category term="go" scheme="http://huangwei.pro/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>pixi.js初体验</title>
    <link href="http://huangwei.pro/2016-02/pixi-test/"/>
    <id>http://huangwei.pro/2016-02/pixi-test/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.567Z</updated>
    
    <content type="html"><![CDATA[<p>有谁还记得<a href="https://www.zhihu.com/people/eastecho" target="_blank" rel="noopener">边城浪子</a>吗？有谁还记得闪客帝国吗？感觉这是个暴露年龄的问题。</p><p>记得我初中那会有了台自己的电脑。然后用猫上网挂着，以可怜的下载速度，用网站抓取软件下载闪客里的Flash小游戏到本地。当然，一到每月话费结算的时候，都少不了家长的一顿揍。</p><p>在知乎上看到边城浪子创建了独立游戏社区<a href="http://indienova.com/" target="_blank" rel="noopener">独立精神</a>，上去看了下，原创和翻译的文章都很赞，而且有很多在线的js动画，能很好的展示相关算法。搞的我也心痒痒想学下js。</p><p>刚好网站上有篇<a href="http://indienova.com/indie-game-development/pixie-js-getting-started/" target="_blank" rel="noopener">pixi.js 初步</a>介绍，看着也挺简单，打算在自己Hexo搭建的这个博客上也用上pixi.js。</p><a id="more"></a><p>遇到这么几个问题，希望对大家有用。</p><ul><li><p>教学文章里创建canvas用的方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> renderer = PIXI.autoDetectRenderer(<span class="number">800</span>, <span class="number">400</span>, &#123;<span class="attr">backgroundColor</span> : <span class="number">0x1099bb</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.view);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>  如果你要指定canvas的话，可以这样：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;canvas id=<span class="string">"canvas"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> renderer = PIXI.autoDetectRenderer(<span class="number">800</span>, <span class="number">400</span>, &#123;<span class="attr">view</span>: canvas&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><ul><li><p>对canvas不能进行<code>getContext</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var canvas</span> = document.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="attribute">var ctx</span> = canvas.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>  我发现<code>getContext</code>之后就绘制不出来了，别问我原因，我js是菜鸟。</p><ul><li><p>要在HTTP服务器环境下运行，直接在本地打开HTML文件是没法使用的。</p><p>比如打开链接<code>file:///D:/source/static/pixitest.html</code>，当创建Sprite的时候，指定img资源路径console显示不能跨域操作。</p></li><li><p>HTML文件放在某些目录下会被Hexo转换掉。这就需要设定忽略目录，在Hexo的<code>_config.yml</code>里配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">'_drafts/**'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'static/**'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>我现在是用<code>iframe</code>方式嵌入。可能是因为我主题的缘故，在md里定义了一些CSS和Script后，显示会出现错乱。用<code>iframe</code>的方式比较独立单纯些，不会跟主题本身的一些定义混杂。</li></ul><p>下面窗口的这个例子，大家可以直接跳转到<a href="/static/pixitest.html">pixitest.html</a>去查看源码。</p><p><br><iframe src="/static/pixitest.html" height="400" width="800"></iframe></p>]]></content>
    
    <summary type="html">
    
      pixi.js 是一款超快开源 HTML5 2D 渲染引擎
    
    </summary>
    
      <category term="js" scheme="http://huangwei.pro/categories/js/"/>
    
    
      <category term="js" scheme="http://huangwei.pro/tags/js/"/>
    
      <category term="pixi" scheme="http://huangwei.pro/tags/pixi/"/>
    
  </entry>
  
  <entry>
    <title>创业小结（二）</title>
    <link href="http://huangwei.pro/2016-01/startup2/"/>
    <id>http://huangwei.pro/2016-01/startup2/</id>
    <published>2016-01-24T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迟来的总结"><a href="#迟来的总结" class="headerlink" title="迟来的总结"></a>迟来的总结</h2><p>时间飞逝，一眨眼就到了2016年了，距离上一篇<a href="http://huangwei.pro/2015-01/startup1/">创业小结</a>刚好过去一年了，本来第一篇也只是记录到2014年第三季度，想着以后有空慢慢补，回头发现这根本就是个假设，翻翻今年在网上买的各种书籍，也是大多没看完，有些连封皮都没来得及拆，真是对自己汗颜。每次想着写总结的时候，都想着先把手头其它事先做完再说，有时还是临时起意加了些事，比如今天用Anconda玩了下IPython和一些数据绘图，然后时间就这么过去了。所以现在就不管其它，先赶在一月结束前写完这篇总结，算是了一桩心事。</p><a id="more"></a><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>有些涉及公司机密和利益相关的就不先表了。先来说说现在的状况吧，第一款产品在2015年初经了过漫长的产品迭代和商务洽谈，安卓版本终于在2015年9月上线，也算是个月流水百万的产品。今年我们的团队规模从不到10人扩大到20人，原来80平不到的小作坊明显已经塞不下这么多人，换了个相当明亮通透的办公间，也有了一间真正的会议室。</p><p>但在这个行业里的朋友应该知道，流水只是账面上的，去除税点、各项成本和渠道分成，到CP手上大约就剩两成。第一款产品的成本约300万，流水的分成不足以支持下一款产品的开发，而且创业积累的经验，让我们越来越明白，在当下的市场环境，小打小闹已经没有啥生存空间。IP、二次元、MOBA、电竞、大厂各种兴奋点在2015年持续爆发，而资本寒冬、产品同质化等因素又导致小CP在大潮之下纷纷倒闭。根据<a href="http://www.199it.com/archives/427459.html" target="_blank" rel="noopener">艾瑞咨询2015年的数据</a>可以看到移动游戏市场依然很红火，但是大厂的垄断格局越来越明显。这是2016新年的新挑战。</p><p>所以我们走在继续融资的路上。在2015年第四季度这样的资本环境下煎熬得等着资方消息，所幸现在都已经走完流程，这颗悬着心暂时放下了。2016年的这波强寒潮袭来，希望今年能够一帆风顺些。</p><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>刚提到团队人员规模的扩大。小团队啥事都得自己亲力亲为，第一个项目上线那会，我既要做运维，要修bug，统计后台数据，还要赶紧开发新功能赶上发行的投放日期。那段时间真是没日没夜，平均每天工作15小时，回家的时候妻儿都一觉睡醒了，一有事就得及时处理。为了结束这种不可持续发展的野蛮模式，人员扩招是不可避免的，但又限于薪资成本考虑，招了2015年和2016年的应届生各一个，加上之前项目后期招的一个学弟，和从<code>网易</code>带出来的学弟，加上自己一共5个程序，一路下来还没人退出。策划团队之前是三人，一个家里有事没等到上线就回老家了，另外一个跟我们闹掰走了。后来找了两个有一两年工作经验的小伙子。</p><p>美术团队基本是做了大换血，从<code>网易</code>工作室跟我们一起出来的两个美术，原本的主美被我们撤职后基本处于残废状态。另外一个在刚担任主美时还是积极负责的，随着与外包沟通的杂事越来越多，也出现了各种疲态，后来因为身体原因就完全歇菜了。而后招的美术UI在主美的“无为而治”的管理下处于放养状态。在上线前后，三位都各自离开，初创时的美术团队在创业一年后分崩离析。</p><p>对于美术团队的组建和主美的选定，我们痛定思痛，总结了几个教训。首先，美术门道比较深，并不是我们预想的那样这搞下那弄下就能出的来，需要自身美术功底好并且能把控好风格的主美来负责。其次，搞美术的人的性格和想法相较于程序或策划更具感性和独特，程序和策划工作更多的是理性和逻辑，所以主美必须懂得如何在美术和团队其他人之间架起沟通桥梁。再者，游戏开发是一种协作式生产流程，对于进度任务和理想目标的追求既相互作用又相互制约，需要主美能够有一定的实战项目经验，懂得进度和理想的权衡。</p><p>所以想来想去，这种量级的主美，只能去大公司挖，而且是合伙人级别，这样的要求和不宽裕的组建时间，找到谈何容易。在创业一年多的时间里，好多时候我们是处于未知和等待中，然后幂幂之中似乎上天总有安排，我们只是顺势而为。这次也是，国内某二线游戏公司手游项目解散，刚好也有朋友关系介绍，见面聊了几次后，那位美术总监便加入我们团队，也成为了我们的合伙人。</p><p>随之发生剧烈变化的美术团队，在一个月之内，我们新增了4位都有大厂项目经验，工作5、6年的美术，年后还会有新人加入。接管和规范了原画、模型、动作、特效、UI等等的美术工作。上天让我们相遇的时机只能说是完美。不过团队总是要经历磨合期的，但有理由相信这次大成本的投入来建设美术团队，能为我们带来效率和质量上的提高。</p><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><p>相对于企业文化，因为按工作类型划分成程序，策划，美术团队，各自团队工作内容不同而产生不同文化（比如程序团队是程序员文化），主要负责人有各自喜好的管理方式（比如我会略喜好一些协作化平台来管理任务和进度，如<a href="https://www.teambition.com" target="_blank" rel="noopener">Teambition</a>），所以我们现在充其量是团队文化。</p><p>由于程序团队里，新人较多，有很大一部分工作要部署学习任务、指导和检查结果。所以虽然现在人多了，但当新人还不能稳定的输出生产代码时，反倒是加重骨干人员的工作量。对于这种情况，原本的解决方案可以集中进行上岗培训，ppt来解释工作方式和流程。但我们一直缺少相应的文档或记录，所以每次新人来都是口口相传，效率低下。</p><p>因为新人暴增，我们给新员工找了合租的房子，这是蛮好的一种新人融入手段，刚好来的略早的新人可以带着刚来的新人一起摸索研究，也相应的减少些骨干人员工作量。分享以前是存放在svn上的，不过<a href="https://www.teambition.com" target="_blank" rel="noopener">Teambition</a>可以上传并且@给某人消息，还是比较方便的，现在我们的日报、分享、任务都是基于这个平台，我也在这安利下它。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>今年希望能产出两款产品，有过了第一款产品的挫折和经历，更了解研发路程的艰辛，还有很多市场不确定因素，但我们还是得一往无前得努力下去。</p><p>然后，产品也会去商谈一些IP合作，为了迎合市场和玩家，这是当下国内游戏圈大家都在挖心思的地方。我承认我们没法做到抛弃现实只关注Gameplay，在独立游戏和商业网游的两头我们还是接近商业多些，毕竟得活下来，对得起一起创业的兄弟。</p><p>技术方向，新项目依然使用Cocos2dx，不过客户端升级了下版本。动作摒弃了CocosStudio，买了Spine的正版授权，虽然Spine在编辑器和功能方面完胜CocosStudio，但是细节上有很多概念与它不同，我们对Spine的library也进行了一番改造（如打断动作时，可能出现的残留问题），后面有空再单独开个文章。</p><p>服务器准备使用Golang来实现，第一个项目为了快速开发使用的是Python，由于其GIL的问题，导致在单核性能不强的云主机上没法发挥多核的优势。其次，Python毕竟不是编译型语言，没有很好的静态代码检查机制，很多时候就需要进行代码覆盖率测试。当然Golang也有各种问题，毕竟语言还很新，GC在1.5之后才得到改善，关键还是Golang开发人员还不多，招人是个大问题。</p><p>不管怎么说，2016年对我们而言，依然是个挑战之年，fighting！</p>]]></content>
    
    <summary type="html">
    
      创业过程中的点点滴滴记录
    
    </summary>
    
      <category term="startup" scheme="http://huangwei.pro/categories/startup/"/>
    
    
      <category term="summary" scheme="http://huangwei.pro/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>关于寻路算法的一些思考（11）：寻路算法的其他应用</title>
    <link href="http://huangwei.pro/2015-09/think-pathfind-11/"/>
    <id>http://huangwei.pro/2015-09/think-pathfind-11/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.568Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的。“关于寻路算法的一些思考”是一个系列，其它部分均由伯乐翻译组其它小伙伴贡献。</p><ul><li><a href="http://blog.jobbole.com/71044/" target="_blank" rel="noopener">关于寻路算法的一些思考（1）：A* 算法介绍</a></li><li><a href="http://blog.jobbole.com/84694/" target="_blank" rel="noopener">关于寻路算法的一些思考（2）：Heuristics 函数</a></li><li><a href="http://blog.jobbole.com/85676/" target="_blank" rel="noopener">关于寻路算法的一些思考（3）：A* 算法的实现</a></li><li><a href="http://blog.jobbole.com/85677" target="_blank" rel="noopener">关于寻路算法的一些思考（4）：A* 算法的变体</a></li><li><a href="http://blog.jobbole.com/83499/" target="_blank" rel="noopener">关于寻路算法的一些思考（5）：处理移动中的障碍物</a></li><li><a href="http://blog.jobbole.com/84660/" target="_blank" rel="noopener">关于寻路算法的一些思考（6）：预先计算好的路径的所用空间</a></li><li><a href="http://blog.jobbole.com/89215/" target="_blank" rel="noopener">关于寻路算法的一些思考（7）：地图表示</a></li><li><a href="http://blog.jobbole.com/83458/" target="_blank" rel="noopener">关于寻路算法的一些思考（8）：长期和短期目标</a></li><li><a href="http://blog.jobbole.com/90682/" target="_blank" rel="noopener">关于寻路算法的一些思考（9）：寻路者的移动成本</a></li><li><a href="http://blog.jobbole.com/83498/" target="_blank" rel="noopener">关于寻路算法的一些思考（10）：最短路径的用户体验</a></li><li><a href="http://blog.jobbole.com/83494/" target="_blank" rel="noopener">关于寻路算法的一些思考（11）：寻路算法的其他应用</a></li><li><a href="http://blog.jobbole.com/90681/" target="_blank" rel="noopener">关于寻路算法的一些思考（12）：AI 技术</a></li></ul><hr><p>除了查找一条可沿着移动找到一个单位的路径之外，寻路在其它方面还有很多用途。</p><a id="more"></a><h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a><strong>探索</strong></h3><p>如果你的成本函数对已知世界的路径进行惩罚，那路径更有可能会通过处女地。这些路径能很好的侦测到其它单位。</p><h3 id="侦查"><a href="#侦查" class="headerlink" title="侦查"></a><strong>侦查</strong></h3><p>如果你的成本函数对敌方瞭望塔等单位附近的路径进行惩罚，那你的单位会倾向保持隐蔽。但请注意，为了能良好运行，你需要考虑到敌方单位的移动，定期更新你的路径。</p><h3 id="道路建设"><a href="#道路建设" class="headerlink" title="道路建设"></a><strong>道路建设</strong></h3><p>从历史上看，道路沿着是经常使用的路径被建造。当路径走的越来越多时，植被被清除，变成泥路，再后来用石头或其它材料覆盖。寻路的一个应用就是找到道路。考虑到人们通行（去城市，湖泊，泉水，矿山等等），会随机得找到这些重要地点之间的路径。在发现上百上千次路径后，确定地图上的哪些空间最常被使用在路径上，然后把这些空间变成道路。跟随探索者喜欢的道路，重复该实验，你会发现更多的道路需要被建设。这种技术可以用于多种类型的道路（高速公路，公路，泥路）：最常用的空间应该变成高速公路，不太常用的空间变成普通公路或者泥路。</p><h3 id="地形分析"><a href="#地形分析" class="headerlink" title="地形分析"></a><strong>地形分析</strong></h3><p>结合势力图，寻路和视线可以给你有趣的方式来分析地形。</p><p>用与道路建设同样的方法，给定一组起点和目标点，我们可以使用寻路来确定哪些区域是最有可能被访问到的，这些区域附近往往具有重要的战略意义。Clash of Civilizations就是使用这种方式来实现它们的地图AI。</p><p>通过进一步分析公共路径，我们可以找到伏击点。路径上没有被视线扫到的位置，继续沿着路径再走N步之后才能被看到，部署伏击点在这些位置上意味着当前敌方无法看到你，直到你们的距离小于N时，这样你就能伏击大部队了。</p><h3 id="城市建设"><a href="#城市建设" class="headerlink" title="城市建设"></a><strong>城市建设</strong></h3><p>城市往往是围绕着自然资源形成的，比如农田和矿产。城市里的居民相互交易需要贸易路线，使用寻路来帮助他们找到自己的贸易路线，并且在路线上标注行进一天的价值。当商队走了一天需要找个地方驻扎时：一个完美的城市位置！沿着一条以上的贸易路线的村庄是用于交易的好地方，最终它会成长为城市。</p><p>道路建设和城市建设相结合可以用于生成出逼真的地图，无论是剧本还是随机地图。</p>]]></content>
    
    <summary type="html">
    
      关于寻路算法的一些思考（11）：寻路算法的其他应用
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="game" scheme="http://huangwei.pro/tags/game/"/>
    
      <category term="pathfinding" scheme="http://huangwei.pro/tags/pathfinding/"/>
    
  </entry>
  
  <entry>
    <title>现代OpenGL教程 04 - 相机，向量，输入</title>
    <link href="http://huangwei.pro/2015-09/modern-opengl4/"/>
    <id>http://huangwei.pro/2015-09/modern-opengl4/</id>
    <published>2015-08-31T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/static/img/opengl-tutorials/modern-opengl-04.png" width="60%"></p><p>本篇教程中，我们会巩固上一篇所提到的矩阵和相机知识，并使用<code>tdogl::Camera</code>类来实现第一人称射击类型的相机。然后，我们会将相机与键盘和鼠标挂钩，使得我们可以移动和浏览3D场景。这里会学一些向量数学，还有上一篇没提到的逆矩阵。</p><a id="more"></a><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>所有例子代码的zip打包可以从这里获取：<a href="https://github.com/tomdalling/opengl-series/archive/master.zip" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series/archive/master.zip</a>。</p><p>这一系列文章中所使用的代码都存放在：<a href="https://github.com/tomdalling/opengl-series" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series</a>。你可以在页面中下载zip，加入你会git的话，也可以复制该仓库。</p><p>本文代码你可以在<code><a href="https://github.com/tomdalling/opengl-series/tree/master/source/04_camera" target="_blank" rel="noopener">source/04_camera</a></code>目录里找到。使用OS X系统的，可以打开根目录里的<code>opengl-series.xcodeproj</code>，选择本文工程。使用Windows系统的，可以在Visual Studio 2013里打开<code>opengl-series.sln</code>，选择相应工程。</p><p>工程里已包含所有依赖，所以你不需要再安装或者配置额外的东西。如果有任何编译或运行上的问题，请联系我。</p><h2 id="向量理论"><a href="#向量理论" class="headerlink" title="向量理论"></a>向量理论</h2><p>在上一篇学了矩阵理论后，你以为数学理论课就结束了？想得太美了，现在下一部分就来了：<a href="http://en.wikipedia.org/wiki/Euclidean_vector" target="_blank" rel="noopener">向量</a>。正统的理解认为向量是3D编程的基础。后面我会展示些代码，是用键盘来进行向量运算，让相机可以在不同方向上移动。</p><p>在3D中（2D中也一样），向量经常用来表示一些不同的东西，比如：</p><ol><li>位置（即，坐标）</li><li>位移（比如，移动）</li><li>方向（比如，南北，上下）</li><li>速度（比如，车的速度和方向）</li><li>加速（比如，重力）</li></ol><p>你可能注意到了上面所提的一些概念都是通常是用来实现物理引擎的。我们在本文中不会实现所有的物理，但为了更好的理解向量，第一步让我们来一些物理教学。</p><p>什么是向量？<mark>一种伪数学的定义上来说，一个向量(vector)就是<em>幅度(magnitude)</em>加上<em>方向</em>。</mark>它能向上，向下，往左，往右，朝北，朝西南等等。你能用3D向量来表示任何一个你指向的方向。向量的另一部分，幅度，表示向量的长度或者大小。</p><p>向量最简单的可视化方式就是绘制它，一般向量都会被绘制为箭头。箭头所指的方向就是向量的方向，箭头的长度就是幅度。下面的图是一个2D向量，但2D的理论同样能应用到3D上。</p><p><img src="/static/img/opengl-tutorials/visual_rep_of_vector.gif" alt=""></p><p><br></p><p>下面用例子来说明向量代表的不同含义。</p><table><thead><tr><th style="text-align:center">&nbsp;</th><th style="text-align:center">方向</th><th style="text-align:center">幅度</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">往北5千米</td><td style="text-align:center">北</td><td style="text-align:center">5千米</td><td style="text-align:center">位置</td></tr><tr><td style="text-align:center">头上5厘米</td><td style="text-align:center">上</td><td style="text-align:center">5厘米</td><td style="text-align:center">位置</td></tr><tr><td style="text-align:center">以50千米每小时开往西湖</td><td style="text-align:center">西湖方向</td><td style="text-align:center">50千米/每小时</td><td style="text-align:center">速度</td></tr><tr><td style="text-align:center">地球引力为9.8m/s<sup>2</sup></td><td style="text-align:center">往地球质心</td><td style="text-align:center">9.8m/s<sup>2</sup></td><td style="text-align:center">加速</td></tr></tbody></table><p><br></p><p><mark>当编码时，向量只是一组数字。每个数字都是向量的“一维”。比如，一个三维3D向量就是有3个数字的数组，2D向量是有2个数字。</mark>因为我们是在3D中进行工作，所以大部分情况只要处理3D向量，但我们也需要用到4D。无论何时我说“向量”，那意味着是3D向量。我们使用GLM的向量数学库，2D，3D，4D的类型分别为<code>glm::vec2</code></p><p>,<code>glm::vec3</code>,<code>glm::vec4</code>。</p><p>3D向量表示顶点，坐标或者位置相当简单。<mark>3D向量的3个维度分别是X，Y，Z的值。</mark>当向量表示位置，方向和幅度时，都是从原点(0,0,0)开始计算的。比如，假设一个物体的XYZ坐标为(0,2,0)，则它的幅度是2，方向为“沿Y轴向上”。</p><h2 id="负向量"><a href="#负向量" class="headerlink" title="负向量"></a>负向量</h2><p><mark>当你要将向量取负时，就是保持相同的幅度，但变成了反方向。</mark></p><p>比如：</p><p><img src="/static/img/opengl-tutorials/vector_negation.gif" alt=""></p><p align="center"><br><br>A=向北5千米<br><br><br>-A=向南5千米<br><br><br></p><p>如果相机的方向是往右的，我们可以使用负向量来算出相机往左的方向。就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 rightDirection = gCamera.right();</span><br><span class="line">glm::vec3 leftDirection = -rightDirection; <span class="comment">//vector negation</span></span><br></pre></td></tr></table></figure><h2 id="标量乘法"><a href="#标量乘法" class="headerlink" title="标量乘法"></a>标量乘法</h2><p><mark>当你将向量乘上一个数值时，新向量的结果表示相同的方向，但幅度被扩大了相应倍数。</mark>这个数值被称为“标量”，这就是为何该乘法被称为“标量乘法”。</p><p>比如：</p><p><img src="/static/img/opengl-tutorials/scalar_mult.gif" alt=""></p><p align="center"><br><br>A=向北5千米<br><br><br>0.5 × A=向北2.5千米<br><br><br>2 × A=向北10千米<br><br><br></p><p>我们可以使用标量乘法来计算基于“移动速度”的相机位置，像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> moveSpeed = <span class="number">2.0</span>; <span class="comment">//units per second</span></span><br><span class="line"><span class="keyword">float</span> distanceMoved = moveSpeed * secondsElapsed;</span><br><span class="line">glm::vec3 forwardDirection = gCamera.forward();</span><br><span class="line">glm::vec3 displacement = distanceMoved * forwardDirection; <span class="comment">//scalar multiplication</span></span><br></pre></td></tr></table></figure><h2 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h2><p>向量加法在2D图形表现下最容易理解。对两个向量进行加法，就是将它们的头部（箭头一段）连接尾部（非箭头一段）。加法顺序不重要。它的结果就是，从第一个向量尾部走向另外一个向量的头部。</p><p><img src="/static/img/opengl-tutorials/vector-addition.gif" alt=""></p><p>注意，即使这些向量看上去是在不同的位置上，但结果向量的幅度（长度）和方向不会改变。请记住，向量<em>只有</em>一个方向和一个幅度。它们没有起始点，所以它们可以在任意不同位置上，但还是相等的。</p><p>比如：</p><blockquote><p>A = 往北1千米</p><p>B = 往西1千米</p><p>A + B = 往西北1.41千米</p></blockquote><p>向量减法相当于是加上一个负向量，比如：</p><blockquote><p>A = 往北1千米</p><p>B = 往西1千米</p><p>A - B = 往西北1.41千米</p><p>A + (-B) = 往西北1.41千米</p></blockquote><p>我们使用向量加法来计算出相机位移后的的新位置，像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 displacement = gCamera.forward() * moveSpeed * secondsElapsed;</span><br><span class="line">glm::vec3 oldPosition = gCamera.position();</span><br><span class="line">glm::vec3 newPosition = oldPosition + displacement; <span class="comment">//vector addition</span></span><br><span class="line">gCamera.setPosition(newPosition);</span><br></pre></td></tr></table></figure><h2 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h2><p><mark>单位向量是幅度为1的向量。它们经常被用来表示方向。</mark></p><p>当一个向量是用来表示方向时，它的幅度就没啥用处。即使这样，我们还是将它的幅度设为1，是为了计算时更方便一些。</p><p>当你在单位向量上使用标量乘法时，它的方向仍然不变，但幅度会被设为标量的值。因此，你将一个单位向量乘上5后，新的向量的幅度就是5。假如你乘上123，那幅度也就是123。基本上这允许我们设置任意一个向量的幅度，而不会更改它的方向。</p><p>让我们对相机进行往左移动12单位的操作。我们先设置一个方向为左的单位向量，然后使用标量乘法将它的幅度设为12，最后使用它来计算出新位置。代码看上去应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `gCamera.right()` returns a unit vector, therefore `leftDirection` will also be a unit vector.</span></span><br><span class="line"><span class="comment">// Negation only affects the direction, not the magnitude.</span></span><br><span class="line">glm::vec3 leftDirection = -gCamera.right();</span><br><span class="line"><span class="comment">//`displacement` will have a magnitude of 12</span></span><br><span class="line">glm::vec3 displacement = leftDirection * <span class="number">12</span>;</span><br><span class="line"><span class="comment">//`newPosition` will be 12 units to the left of `oldPosition`</span></span><br><span class="line">glm::vec3 newPosition = oldPosition + displacement;</span><br></pre></td></tr></table></figure><p>任何一个向量都能变为单位向量。这个操作叫做<em>单位化</em>。我们可以用GLM来单位化一个向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 someRandomVector = glm::vec3(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br><span class="line">glm::vec3 unitVector = glm::normalize(someRandomVector);</span><br></pre></td></tr></table></figure><h2 id="tdogl-Camera类"><a href="#tdogl-Camera类" class="headerlink" title="tdogl::Camera类"></a>tdogl::Camera类</h2><p>恭喜你看到这儿了！现在你已经有足够的向量知识了，来，让我们开始编码。</p><p><a href="https://github.com/tomdalling/opengl-series/blob/master/source/04_camera/source/tdogl/Camera.h" target="_blank" rel="noopener"><code>tdogl::Camera</code>类的接口</a>在<a href="https://github.com/tomdalling/opengl-series/blob/master/source/04_camera/source/tdogl/Camera.h" target="_blank" rel="noopener">这里</a>，实现代码在<a href="https://github.com/tomdalling/opengl-series/blob/master/source/04_camera/source/tdogl/Camera.cpp" target="_blank" rel="noopener">这里</a>。</p><p>在前面文章中我们在OpenGL中用矩阵来实现相机。<code>tdogl::Camera</code>类可以基于各种属性来创建矩阵，比如：</p><ul><li>相机位置</li><li>相机朝向（方向）</li><li>缩放（视野）</li><li>最大和最小可视距离（远近平面）</li><li>视口/窗口纵横比</li></ul><p>上面的每个属性都有各自的设置和获取接口。前文已经介绍过了。</p><p>现在让我们用<code>matrix</code>和<code>orientation</code>方法来实现如何让这所有属性组合成一个矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 Camera::matrix() <span class="keyword">const</span> &#123;</span><br><span class="line">    glm::mat4 camera = glm::perspective(_fieldOfView, _viewportAspectRatio, _nearPlane, _farPlane);</span><br><span class="line">    camera *= orientation();</span><br><span class="line">    camera = glm::translate(camera, -_position);</span><br><span class="line">    <span class="keyword">return</span> camera;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glm::mat4 Camera::orientation() <span class="keyword">const</span> &#123;</span><br><span class="line">    glm::mat4 orientation;</span><br><span class="line">    orientation = glm::rotate(orientation, _verticalAngle, glm::vec3(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    orientation = glm::rotate(orientation, _horizontalAngle, glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> orientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，最终的相机矩阵是由四个不同的变换组成。按顺序是：</p><ul><li>移动，基于相机位置</li><li>旋转，基于相机水平（左/右）转角</li><li>旋转，基于相机垂直（上/下）转角</li><li>透视，基于视野，近平面，远平面和纵横比</li></ul><p>假如你觉得这顺序是反的，那请记住矩阵乘法是从右往左，代码上顺序是从底往上。</p><p>注意，移动用了相机的<em>负</em>位置。这里再次用前文提到的方式，我们可以让3D场景往后来实现相机往前走。向量为负时会反转其方向，所以“往前”就变成“往后”。</p><p><code>tdogl::Camera</code>类还有其它方法来返回单位向量：<code>上</code>,<code>右</code>和<code>前</code>。我们需要从键盘获取消息来实现相机移动。</p><h2 id="相机方位矩阵求逆"><a href="#相机方位矩阵求逆" class="headerlink" title="相机方位矩阵求逆"></a>相机方位矩阵求逆</h2><p>让我来看下<code>tdogl::Camera::up</code>方法的实现，这里有两个东西我们还没有提及。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 Camera::up() <span class="keyword">const</span> &#123;</span><br><span class="line">    glm::vec4 up = glm::inverse(orientation()) * glm::vec4(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> glm::vec3(up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到它使用了<code>glm::inverse</code>方法。从上一篇文章中，我们知道矩阵能对坐标进行变换。在这里，我们还需要对坐标进行“反变换”，使得我们能获得矩阵乘法变换前的坐标。为了实现这个目的，我们需要计算<em>逆</em>矩阵。<mark>逆矩阵是一个矩阵，<em>完全相反</em>于另外一个矩阵，这意味着它能<em>撤销</em>另外一个矩阵的变换。</mark>比如，矩阵<code>A</code>是绕着Y轴旋转90°，那矩阵<code>A</code>的逆矩阵就是绕着Y轴旋转-90°。</p><p>当相机的方向改变时，“向上”的方向也随之改变。比如，想象下有个箭头指向你的头顶，假如你旋转你的头往地上看，那箭头就是向前倾斜，假如你往天上看，那箭头是向后倾斜的。如果你往前看，就是你的头“不旋转”，那箭头就是笔直向上。我们用“笔直向上”的单位向量(0,1,0)来表示相机的向上方向，“不旋转”使用相机方位矩阵的逆矩阵。另外一种解释，在相机旋转后，向上方向总是为(0,1,0)，所以我们要将逆旋转乘上(0,1,0)，这就能得到相机旋转前的向上方向。</p><p>(0,1,0)是单位向量，当你旋转一个单位向量结果还是一个单位向量。假如结果<em>不是</em>单位向量，你应该使用<code>glm::normalize</code>来单位化。</p><p>计算相机的<code>前</code>和<code>右</code>方向是同样的方式。</p><p>你可能注意到了这里用了一个4D向量<code>glm::vec4</code>。前文解释过，4x4 矩阵(<code>glm::mat4</code>)需要一个4D向量来进行矩阵乘法，使用<code>glm::vec3</code>会导致编译错误。只要把3D向量(0,1,0)变成4D向量(0,1,0,1)就可以进行矩阵乘法了，计算完成后我们再将4D向量变回3D向量。</p><h2 id="整合tdogl-Camera类"><a href="#整合tdogl-Camera类" class="headerlink" title="整合tdogl::Camera类"></a>整合tdogl::Camera类</h2><p>现在我们开始使用<code>tdogl:Camera</code>类。</p><p>在之前的文章中，我们分别设置了投影矩阵和相机矩阵两个着色器变量。在本文中，<code>tdogl::Camera</code>合并了这两个矩阵，所以让我们移除<code>projection</code>着色器变量，只用<code>camera</code>变量就足够了。下面是顶点着色器的更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line"></span><br><span class="line">uniform mat4 camera;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line">in vec3 vert;</span><br><span class="line">in vec2 vertTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the tex coord straight through to the fragment shader</span></span><br><span class="line">    fragTexCoord = vertTexCoord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply all matrix transformations to vert</span></span><br><span class="line">    gl_Position = camera * model * vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将<code>tdogl::Camera</code>整合到<code>main.cpp</code>中。首先包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tdogl/Camera.h"</span></span></span><br></pre></td></tr></table></figure><p>然后声明全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tdogl::Camera gCamera;</span><br></pre></td></tr></table></figure><p>在前一篇文章中，相机和投影矩阵是不会改变的，所以在<code>LoadShaders</code>函数中设置一次就好了。但在本文中，因为我们需要用鼠标和键盘来控制，所以设置相机矩阵要放在<code>Render</code>函数中并每帧都要设置一下。首先让我们移除旧代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadShaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tdogl::Shader&gt; shaders;</span><br><span class="line">    shaders.push_back(tdogl::Shader::shaderFromFile(ResourcePath(<span class="string">"vertex-shader.txt"</span>), GL_VERTEX_SHADER));</span><br><span class="line">    shaders.push_back(tdogl::Shader::shaderFromFile(ResourcePath(<span class="string">"fragment-shader.txt"</span>), GL_FRAGMENT_SHADER));</span><br><span class="line">    gProgram = <span class="keyword">new</span> tdogl::Program(shaders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the commented-out code below was removed</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    gProgram-&gt;use();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //set the "projection" uniform in the vertex shader, because it's not going to change</span></span><br><span class="line"><span class="comment">    glm::mat4 projection = glm::perspective&lt;float&gt;(50.0, SCREEN_SIZE.x/SCREEN_SIZE.y, 0.1, 10.0);</span></span><br><span class="line"><span class="comment">    //glm::mat4 projection = glm::ortho&lt;float&gt;(-2, 2, -2, 2, 0.1, 10);</span></span><br><span class="line"><span class="comment">    gProgram-&gt;setUniform("projection", projection);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //set the "camera" uniform in the vertex shader, because it's also not going to change</span></span><br><span class="line"><span class="comment">    glm::mat4 camera = glm::lookAt(glm::vec3(3,3,3), glm::vec3(0,0,0), glm::vec3(0,1,0));</span></span><br><span class="line"><span class="comment">    gProgram-&gt;setUniform("camera", camera);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    gProgram-&gt;stopUsing();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>Render</code>函数中设置<code>camera</code>着色器变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// draws a single frame</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// clear everything</span></span><br><span class="line">    glClearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// black</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind the program (the shaders)</span></span><br><span class="line">    gProgram-&gt;use();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the "camera" uniform</span></span><br><span class="line">    gProgram-&gt;setUniform(<span class="string">"camera"</span>, gCamera.matrix());</span><br></pre></td></tr></table></figure><p><code>gCamera.matrix()</code>函数返回的是一个<code>glm::mat4</code>, 并且<code>setUniform</code>函数使用了<code>glUniformMatrix4fv</code>来设置顶点着色器中的相机矩阵uniform变量。</p><p>在<code>AppMain</code>函数中设置相机的初始化位置和视窗纵横比。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gCamera.setPosition(glm::vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">gCamera.setViewportAspectRatio(SCREEN_SIZE.x / SCREEN_SIZE.y);</span><br></pre></td></tr></table></figure><p>其余相机属性都留成默认值。</p><p>你现在运行程序，会看到上次实现的旋转立方体。下一步就让我们用鼠标和键盘来控制相机。</p><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>我们先来实现键盘控制。每次我们更新屏幕时，我们先检查’W’,’A’,’S’或’D’按键是否被按下，如果有触发那就稍微移动下相机。函数<code>glfwGetKey</code>返回一个布尔值来表示这个按键是否按下。新的<code>Update</code>函数看上去是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update the scene based on the time elapsed since last update</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//rotate the cube</span></span><br><span class="line">    <span class="keyword">const</span> GLfloat degreesPerSecond = <span class="number">180.0f</span>;</span><br><span class="line">    gDegreesRotated += secondsElapsed * degreesPerSecond;</span><br><span class="line">    <span class="keyword">while</span>(gDegreesRotated &gt; <span class="number">360.0f</span>) gDegreesRotated -= <span class="number">360.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//move position of camera based on WASD keys</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> moveSpeed = <span class="number">2.0</span>; <span class="comment">//units per second</span></span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'S'</span>))&#123;</span><br><span class="line">        gCamera.offsetPosition(secondsElapsed * moveSpeed * -gCamera.forward());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'W'</span>))&#123;</span><br><span class="line">        gCamera.offsetPosition(secondsElapsed * moveSpeed * gCamera.forward());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'A'</span>))&#123;</span><br><span class="line">        gCamera.offsetPosition(secondsElapsed * moveSpeed * -gCamera.right());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'D'</span>))&#123;</span><br><span class="line">        gCamera.offsetPosition(secondsElapsed * moveSpeed * gCamera.right());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先忽略立方体的旋转。</p><p>当<code>S</code>键被按下时，我们可以看得更近些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gCamera.offsetPosition(secondsElapsed * moveSpeed * -gCamera.forward());</span><br></pre></td></tr></table></figure><p>这一行代码做了好多事，让我们用更容易懂的方式重写一遍，新的函数叫<code>MoveCameraBackwards</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveCameraBackwards</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> finish writing this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向后是一个方向，所以应该是个单位向量。在相机类中没有<code>backward</code>函数，但它有个<code>forward</code>函数。向后就是向前的反方向，所以我们只要对向前的单位向量取负数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveCameraBackwards</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//`direction` is a unit vector, set to the "backwards" direction</span></span><br><span class="line">    glm::vec3 direction = -gCamera.forward();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> finish writing this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们应该知道将相机移多<em>远</em>。我们有相机的移动速度<code>moveSpeed</code>，我们还知道从上一帧到现在过去了多少时间<code>secondsElapsed</code>。对这两个值进行乘法，就能得到相机移动的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveCameraBackwards</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//`direction` is a unit vector, set to the "backwards" direction</span></span><br><span class="line">    glm::vec3 direction = -gCamera.forwards();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`distance` is the total distance to move the camera</span></span><br><span class="line">    <span class="keyword">float</span> distance = moveSpeed * secondsElapsed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> finish writing this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们知道了移动的距离和方向，我们就能构造一个位移向量。它的幅度就是<code>distance</code>，它的方向就是<code>direction</code>。因为<code>direction</code>是个单位向量，我们可以用标量乘法来设置幅度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveCameraBackwards</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//`direction` is a unit vector, set to the "backwards" direction</span></span><br><span class="line">    glm::vec3 direction = -gCamera.forwards(); <span class="comment">//vector negation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`distance` is the total distance to move the camera</span></span><br><span class="line">    <span class="keyword">float</span> distance = moveSpeed * secondsElapsed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`displacement` is a combination of `distance` and `direction`</span></span><br><span class="line">    glm::vec3 displacement = distance * direction; <span class="comment">//scalar multiplication</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> finish writing this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们移动（或者说是置换）相机当前位置。用向量加法即可。最基础的公式<code>newPosition = oldPosition + displacement</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveCameraBackwards</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//`direction` is a unit vector, set to the "backwards" direction</span></span><br><span class="line">    glm::vec3 direction = -gCamera.forwards(); <span class="comment">//vector negation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`distance` is the total distance to move the camera</span></span><br><span class="line">    <span class="keyword">float</span> distance = moveSpeed * secondsElapsed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`displacement` is a combination of `distance` and `direction`</span></span><br><span class="line">    glm::vec3 displacement = distance * direction; <span class="comment">//scalar multiplication</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//change the position of the camera</span></span><br><span class="line">    glm::vec3 oldPosition = gCamera.position();</span><br><span class="line">    glm::vec3 newPosition = oldPosition + displacement; <span class="comment">//vector addition</span></span><br><span class="line">    gCamera.setPosition(newPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了！<code>MoveCameraBackwards</code>函数这么多行代码跟这一行代码是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gCamera.offsetPosition(secondsElapsed * moveSpeed * -gCamera.forward());</span><br></pre></td></tr></table></figure><p><code>offsetPosition</code>函数做的就是向量加法，它将位移向量作为参数传入。让我们使用那一行代码来替换<code>MoveCameraBackwards</code>函数，因为简洁就是美。</p><p>其余按键的工作方式都是相同的，无非是方向不同而已。让我们再添加<code>Z</code>和<code>X</code>键来实现相机上和下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'Z'</span>))&#123;</span><br><span class="line">    gCamera.offsetPosition(secondsElapsed * moveSpeed * -glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(glfwGetKey(gWindow, <span class="string">'X'</span>))&#123;</span><br><span class="line">    gCamera.offsetPosition(secondsElapsed * moveSpeed * glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为什么这里用向量(0,1,0)而不是<code>gCamera.up()</code>。记住，“向上”方向会随着相机方向而改变。假如相机看地上，“向上”指的是向前，假设相机看天上，“向上”指的是向后。这并不是我想实现的行为，我希望的是“笔直向上”的方向(0,1,0)，不依赖于相机的方向。</p><p>现在当你运行程序，你能使用<code>W</code>, <code>A</code>, <code>S</code>, <code>D</code>, <code>X</code>,和<code>Z</code>键来向前移动，向左移动，向后移动，向右移动，向上移动和向下移动。观察时不会因为相机移动而改变方向，这个将留个鼠标来控制。</p><h2 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h2><p>此时，我们的窗口还无法捕捉鼠标消息。你能看到鼠标在窗口上移来移去。我希望它消失，并且不希望它移出窗口。为了实现这个，我们要改下GLFW的设置。</p><p>在我们捕获鼠标之前，让我们先实现用取消键（Esc）退出程序。我不想再点击关闭按钮了，因为鼠标隐藏，并且无法离开窗口。让我们在<code>AppMain</code>主循环下放加上些代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run while the window is open</span></span><br><span class="line"><span class="keyword">double</span> lastTime = glfwGetTime();</span><br><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(gWindow))&#123;</span><br><span class="line">    <span class="comment">// process pending events</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the scene based on the time elapsed since last update</span></span><br><span class="line">    <span class="keyword">double</span> thisTime = glfwGetTime();</span><br><span class="line">    Update((<span class="keyword">float</span>)(thisTime - lastTime));</span><br><span class="line">    lastTime = thisTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw one frame</span></span><br><span class="line">    Render();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for errors</span></span><br><span class="line">    GLenum error = glGetError();</span><br><span class="line">    <span class="keyword">if</span>(error != GL_NO_ERROR)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"OpenGL Error "</span> &lt;&lt; error &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//exit program if escape key is pressed</span></span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(gWindow, GLFW_KEY_ESCAPE))</span><br><span class="line">        glfwSetWindowShouldClose(gWindow, GL_TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们用<code>glfwCreateWindow</code>打开窗口这样设置时，就可以捕获鼠标了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLFW settings</span></span><br><span class="line">glfwSetInputMode(gWindow, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line">glfwSetCursorPos(gWindow, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这段代码让鼠标消失了，并且将它移动到了像素坐标(0,0)。在<code>Update</code>中，我们会获取鼠标位置来更新相机，更新完后将鼠标坐标再次设为(0,0)。这种方式可以很方便的看出每帧鼠标移动了多少，还要在当鼠标要移出窗口时停住它。在<code>Update</code>函数下面添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rotate camera based on mouse movement</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> mouseSensitivity = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">double</span> mouseX, mouseY;</span><br><span class="line">glfwGetCursorPos(gWindow, &amp;mouseX, &amp;mouseY);</span><br><span class="line">gCamera.offsetOrientation(mouseSensitivity * (<span class="keyword">float</span>)mouseY, mouseSensitivity * (<span class="keyword">float</span>)mouseX);</span><br><span class="line">glfwSetCursorPos(gWindow, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//reset the mouse, so it doesn't go out of the window</span></span><br></pre></td></tr></table></figure><p>鼠标的坐标单位是像素，但相机方向是基于两个角度。这就是为何我们使用<code>mouseSensitivity</code>变量来将像素转为角度。越大的鼠标灵敏度，相机转向的越快，越小的灵敏度，转向的越慢。灵敏度设为<code>0.1f</code>的含义就是每10像素就旋转1°。</p><p><code>offsetOrientation</code>函数类似于<code>offsetPosition</code>函数，它会使用水平和垂直角度来更新相机方向。</p><p>好了！基本到这就完成了。你现在运行程序的话，你能绕着飞行并且<a href="http://en.wikipedia.org/wiki/Gimbal_lock" target="_blank" rel="noopener">几乎</a>能观察任意方向。立方体的旋转动画可能会让你在环绕时失去方向感，我们可以关闭它。</p><h2 id="用鼠标滚轮控制视野"><a href="#用鼠标滚轮控制视野" class="headerlink" title="用鼠标滚轮控制视野"></a>用鼠标滚轮控制视野</h2><p>就像蛋糕上的糖衣一样，我们可以滚动鼠标或者在触摸板上滑动来实现相机镜头的视野缩放。上篇文章我们已经解释过视野的概念了。</p><p>我们使用同样的方式来使用鼠标位置，并且每帧重置滚动值。首先我们创建一个全局变量来保存滚动值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> gScrollY = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>使用GLFW来接受滚轮消息，首先我们得创建个回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// records how far the y axis has been scrolled</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnScroll</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">  gScrollY += deltaY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用GLFW在<code>AppMain</code>中注册下回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetScrollCallback(gWindow, OnScroll);</span><br></pre></td></tr></table></figure><p>当每帧我们渲染的时候，我们使用<code>gScrollY</code>值来更改视野。代码放在<code>Update</code>函数的下放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> zoomSensitivity = <span class="number">-0.2f</span>;</span><br><span class="line"><span class="keyword">float</span> fieldOfView = gCamera.fieldOfView() + zoomSensitivity * (<span class="keyword">float</span>)gScrollY;</span><br><span class="line"><span class="keyword">if</span>(fieldOfView &lt; <span class="number">5.0f</span>) fieldOfView = <span class="number">5.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(fieldOfView &gt; <span class="number">130.0f</span>) fieldOfView = <span class="number">130.0f</span>;</span><br><span class="line">gCamera.setFieldOfView(fieldOfView);</span><br><span class="line">gScrollY = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>zoomSensitivity</code>常量类似<code>mouseSensitivity</code>常量。视野取值范围是0°到180°，但假如你设置的值离上下限很近的话，3D场景看上去会很奇怪，所以我们限制这个值范围在5°到130°。类似鼠标位置的方法，我们在每帧之后设置<code>gScrollY = 0</code>。</p><h2 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h2><p>下一篇文章，我们会重构代码来实现最最基本的“引擎”。我们会将代码分为资产（资源）和实例，类似典型的3D引擎，可以生成有多个略微不同的木箱子的3D场景。</p><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul><li><a href="http://www.arcsynthesis.org/gltut/Basics/Introduction.html" target="_blank" rel="noopener">The vector math chapter of Learning Modern 3D Graphics Programming</a> by Jason L. McKesson</li><li><a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/" target="_blank" rel="noopener">Vector maths – a primer for games programmers</a></li><li><a href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-vectors" target="_blank" rel="noopener">Basic 3D Math: Vectors</a> by Egon Rath</li><li><a href="http://en.wikipedia.org/wiki/Euclidean_vector" target="_blank" rel="noopener">Wikipedia article on vectors</a>, which isn’t very beginner-friendly</li><li>The GLFW <a href="http://www.glfw.org/docs/3.0.4/pages.html" target="_blank" rel="noopener">guides</a> and <a href="http://www.glfw.org/docs/3.0.4/modules.html" target="_blank" rel="noopener">references</a>.</li><li>假如你有任何关于向量方面对初学者友好的文章，请发送给我，我会添加进来。</li></ul>]]></content>
    
    <summary type="html">
    
      现代OpenGL教程 04 - 相机，向量，输入
    
    </summary>
    
      <category term="modern-opengl-tutorials" scheme="http://huangwei.pro/categories/modern-opengl-tutorials/"/>
    
    
      <category term="opengl" scheme="http://huangwei.pro/tags/opengl/"/>
    
      <category term="tutorials" scheme="http://huangwei.pro/tags/tutorials/"/>
    
  </entry>
  
  <entry>
    <title>现代OpenGL教程 03 - 矩阵，深度缓冲，动画</title>
    <link href="http://huangwei.pro/2015-08/modern-opengl3/"/>
    <id>http://huangwei.pro/2015-08/modern-opengl3/</id>
    <published>2015-08-12T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/static/img/opengl-tutorials/modern-opengl-03.png" width="60%"></p><p>本文中，我会将不会动的2D三角形替换为旋转的3D立方体。你会看到这样的效果：</p><p><img src="/static/img/opengl-tutorials/rotating-crate.gif" alt=""></p><p>现在我们终于能在屏幕上搞点有趣的东西了，我放了更多的动图在这里：<a href="http://imgur.com/a/x8q7R" target="_blank" rel="noopener">http://imgur.com/a/x8q7R</a></p><p>为了生成旋转立方体，我们需要学些关于矩阵的数学，用于创建透视投影，旋转，平移和“相机”概念。我们还有必要学习些深度缓冲，和典型的随时间改变的3D应用，比如动画。</p><a id="more"></a><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>所有例子代码的zip打包可以从这里获取：<a href="https://github.com/tomdalling/opengl-series/archive/master.zip" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series/archive/master.zip</a>。</p><p>这一系列文章中所使用的代码都存放在：<a href="https://github.com/tomdalling/opengl-series" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series</a>。你可以在页面中下载zip，加入你会git的话，也可以复制该仓库。</p><p>本文代码你可以在<code><a href="https://github.com/tomdalling/opengl-series/tree/master/source/03_matrices" target="_blank" rel="noopener">source/03_matrices</a></code>目录里找到。使用OS X系统的，可以打开根目录里的<code>opengl-series.xcodeproj</code>，选择本文工程。使用Windows系统的，可以在Visual Studio 2013里打开<code>opengl-series.sln</code>，选择相应工程。</p><p>工程里已包含所有依赖，所以你不需要再安装或者配置额外的东西。如果有任何编译或运行上的问题，请联系我。</p><h2 id="矩阵原理"><a href="#矩阵原理" class="headerlink" title="矩阵原理"></a>矩阵原理</h2><p>本文讲的最多的就是关于3D中的矩阵，所以让我们在写代码前先了解下矩阵原理。我不会过多关注数学，网上有很多好的这类资源。我们只需要使用GLM来实现相关运算。我会注重于那些应用在我们3D程序里的矩阵。</p><p><mark>矩阵是用来进行3D变换。</mark>可能的变换包括（点击可以看动画）：</p><ul><li><a href="http://en.wikipedia.org/wiki/Rotation_matrix" target="_blank" rel="noopener">旋转</a></li><li><a href="http://imgur.com/a/x8q7R#6" target="_blank" rel="noopener">缩放</a>（变大和变小）</li><li><a href="http://en.wikipedia.org/wiki/Translation_(geometry" target="_blank" rel="noopener">平移</a>)（移动）</li><li><a href="http://imgur.com/a/x8q7R#0" target="_blank" rel="noopener">透视/正交 投影</a>（后面会解释）</li></ul><p>一个矩阵是一个数字表格，像这样：</p><p><img src="/static/img/opengl-tutorials/mat4x4.png" alt=""></p><p>矩阵英文matrix的复数形式是matrices。</p><p>不同的数值的能产生不同类型的变换。上面的那个矩阵会绕着Z轴旋转90°。我们会使用GLM来创建矩阵，所以我们不用理解如何计算出这些数值。</p><p>矩阵可以有任意行和列，但3D变换使用4×4矩阵，就像上面看到的那样。无论我在那说到“矩阵”，指的就是4×4矩阵。</p><p>当用代码实现矩阵时，一般会用一个浮点数组来表示。我们使用<code>glm::mat4</code>类来表示4×4矩阵。</p><p>两个最重要的矩阵操作是：</p><ul><li><mark>matrix × matrix = combined matrix</mark></li><li><mark>matrix × coordinate = transformed coordinate </mark></li></ul><h2 id="矩阵-×-矩阵"><a href="#矩阵-×-矩阵" class="headerlink" title="矩阵 × 矩阵"></a>矩阵 × 矩阵</h2><p>当你要对两个矩阵进行相乘时，它们的乘积是一个包含两者变换的新矩阵。</p><p>比如，你将一个旋转矩阵乘以一个平移矩阵，得到的结果就是“组合”矩阵，即先旋转然后平移。下面的例子展示这类矩阵相乘。</p><p><img src="/static/img/opengl-tutorials/mat-x-mat.png" alt=""></p><p><mark>不像普通的乘法，矩阵乘法中顺序很重要。</mark> 比如，<code>A</code>和<code>B</code>是矩阵，<code>A*B</code>不一定等于<code>B*A</code>。下面我们会使用相同的矩阵，但改变下乘法顺序：</p><p><img src="/static/img/opengl-tutorials/mat-x-mat-commutative.png" alt=""></p><p>注意不同的顺序，结果也不同。下面动画说明顺序有多重要。相同的矩阵，不同的顺序。两个变换分别是沿Y轴上移，和旋转45°。</p><p><img src="/static/img/opengl-tutorials/rotate-translate.gif" alt=""></p><p><img src="/static/img/opengl-tutorials/translate-rotate.gif" alt=""></p><p>当你编码的时候，假如看到变换出错，请回头检查下你的矩阵运算是否是正确的顺序。</p><h2 id="矩阵-×-坐标"><a href="#矩阵-×-坐标" class="headerlink" title="矩阵 × 坐标"></a>矩阵 × 坐标</h2><p>当你用矩阵乘以一个坐标时，它们的乘积就是一个变换后的新坐标。</p><p>比如，你有上面提到的旋转矩阵，乘上坐标(1,1,0)，它的结果就是(-1,1,0)。变换后的坐标就是原始坐标绕着Z周旋转90°。下面是该乘法的图例：</p><p><img src="/static/img/opengl-tutorials/mat-x-vec.png" alt=""></p><h2 id="为何我们会使用4D坐标"><a href="#为何我们会使用4D坐标" class="headerlink" title="为何我们会使用4D坐标"></a>为何我们会使用4D坐标</h2><p>你可能注意到了上面的坐标是4D的，而非3D。它的格式是这样的：</p><p><img src="/static/img/opengl-tutorials/homo-coord-letters.png" alt=""></p><p>为何我们会使用4D坐标？因为我们需要用4x4的矩阵完成所有我们需要的3D变换。不管怎样，矩阵乘法需要左边的列数等于右边的行数。这就意味着4x4矩阵无法与3D坐标相乘，因为矩阵有4列，但坐标只有3行。<mark>我们需要使用4D坐标，因为4x4的矩阵<em>需要</em>用它们来完成矩阵运算。</mark></p><p>一些变换，比如旋转，缩放，只需要3x3矩阵。对于这些变换，我们不需要4D坐标，因为3D坐标就能运算。但无论如何，变换需要至少是4x3的矩阵，而透视投影矩阵需要4x4矩阵，而我们两者都会用到，所以我们强制使用4D。</p><p>这些被称为<a href="http://en.wikipedia.org/wiki/Homogeneous_coordinates" target="_blank" rel="noopener">齐次坐标</a>。在后续的教程里，我们会讲到有向光照，那里我们会学到有关“W”维度的表示。在这里，我们只需要将3D转换为4D。3D转换为4D只要将第四维坐标“W”设为1即可。比如，坐标(22,33,44)转换为：</p><p><img src="/static/img/opengl-tutorials/homo-coord.png" alt=""></p><p>当需要将4D坐标变为3D时，假如“W”维度是1，你可以直接忽略它，使用X，Y，Z的值即可。如果你发现“W”的值不为1，好吧，你就需要做些额外处理，或者这里出了个bug。</p><h2 id="构造一个立方体"><a href="#构造一个立方体" class="headerlink" title="构造一个立方体"></a>构造一个立方体</h2><p>代码上第一个变动就是用立方体替换之前的三角形。</p><p>我们用三角形来构造立方体，用两个三角形表示6个面的每个面。在旧版本的OpengGL中，我们可以使用1个正方形（<code>GL_QUADS</code>）来替代2个三角表示每个面，但<code>GL_QUADS</code>已经被现代版本的OpenGL给移除了。X，Y，Z坐标值域为-1到1，这意味着立方体是两个单位宽，立方体中心点在原点（原点坐标(0,0,0)）。我们将使用256×256的贴图给立方体每个面贴上。后序文章中都会使用这个数据，我们不需要改变太多。这里有立方体数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertexData[] = &#123;</span><br><span class="line">    <span class="comment">//  X     Y     Z       U     V</span></span><br><span class="line">    <span class="comment">// bottom</span></span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// front</span></span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// back</span></span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left</span></span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right</span></span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,<span class="number">-1.0f</span>, <span class="number">1.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>,<span class="number">-1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要更改下<code>Render</code>函数中<code>glDrawArrays</code>调用，之前是用来绘制三角形的。立方体6个面，每个面有2个三角形，每个三角形有3个顶点，所以需要绘制的顶点数是：6 × 2 × 3 = 36。新的<code>glDrawArrays</code>调用像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>*<span class="number">2</span>*<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>最后，我们使用新的贴图“wooden-crate.jpg”，我们更改<code>LoadTexture</code>中的文件名，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tdogl::Bitmap bmp = tdogl::Bitmap::bitmapFromFile(ResourcePath(<span class="string">"wooden-crate.jpg"</span>));</span><br></pre></td></tr></table></figure><p>就是这样！我们已经提供了所有绘制带贴图立方体的需要用到的数据。假如你运行程序，你可以看到这样的：</p><p><img src="/static/img/opengl-tutorials/crate-stretched.jpg" alt=""></p><p>此时此刻，我们有两个问题。第一，这个立方体看上去非常2D，因为我们只看到了一个面。我们需要“移动相机”，以不同角度观察这个立方体。第二，上面有些问题，因为立方体宽和高应该相等，但从截图看上去宽度明显比高度大。为了修复这两个问题，我们需要学习更多的矩阵知识，和如何应用到3D程序中。</p><h2 id="裁剪体-默认相机"><a href="#裁剪体-默认相机" class="headerlink" title="裁剪体 - 默认相机"></a>裁剪体 - 默认相机</h2><p>为了理解3D中的“相机”，我们首先得理解裁剪体。</p><p><mark>裁剪体是一个立方体。无论什么东西在裁剪体中的都会显示在屏幕上，任何在裁剪体之外的都不会显示。</mark>裁剪体跟我们上面的立方体是相同大小，它的X，Y，Z坐标值域也是从-1到+1。-X表示左边，+X表示右边，-Y是底部，+Y是顶部，+Z是远离相机，-Z是朝着相机。</p><p>因为我们的立方体和裁剪体一样大，所以我们只能看到立方体的正面。</p><p>这也解释了为何我们的立方体看起来比较宽。窗口显示了裁剪体里的所有东西。窗口的左右边缘是X轴的-1和+1，窗口的底部和顶部边缘是Y轴的-1和+1。裁剪体被拉伸了，用来跟窗口的可视大小相适应，所以我们的立方体看上去不是正方形的。</p><h2 id="固定住相机，让世界移动起来"><a href="#固定住相机，让世界移动起来" class="headerlink" title="固定住相机，让世界移动起来"></a>固定住相机，让世界移动起来</h2><p>我们需要移动相机，使得可以从不同角度进行观察，或放大缩小。但不管怎样，<mark>裁剪体不会更改。它永远是一样的大小和位置。所以我们换种方式来替代移动相机，我们可以移动3D场景让它正确得出现在裁剪体中。</mark>比如，我们想要让相机往右旋转，我们可以把整个世界往左旋转。假如我们想要让相机离玩家近些，我们可以把玩家挪到相机前。这就是“相机”在3D中的工作方式，变换整个世界使得它出现在裁剪体中并且看上去是正确的。</p><p>无论你走到哪里，都会觉得是世界没动，是你在移动。但你也能想象出当你不动，而世界在你脚下滚动，就像你在跑步机上一样。这就是“移动相机”和“移动世界”的区别，这两种方式，对于观察者而言，看上去都是一样的。</p><p>我们如何对3D场景进行变换来适应裁剪体呢？这里我们需要用到矩阵。</p><h2 id="实现相机矩阵"><a href="#实现相机矩阵" class="headerlink" title="实现相机矩阵"></a>实现相机矩阵</h2><p>让我们先来实现相机矩阵。3D中“相机”的解释可认为是对3D场景的一系列变换。因为相机就是一个变换，所以我们可以用矩阵来表示。</p><p>首先，我们需要包含GLM头文件，用来创建不同类型的矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>接着，我们需要更新顶点着色器。我们创建一个相机矩阵变量叫做<code>camera</code>，并且每个顶点都会乘上这个相机矩阵。这样我们就将整个3D场景进行了变换。每个顶点都会被相机矩阵所变换。新的顶点着色器看上去应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line"></span><br><span class="line">uniform mat4 camera; <span class="comment">//this is the new variable</span></span><br><span class="line"></span><br><span class="line">in vec3 vert;</span><br><span class="line">in vec2 vertTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the tex coord straight through to the fragment shader</span></span><br><span class="line">    fragTexCoord = vertTexCoord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the input vertex with the camera matrix</span></span><br><span class="line">    gl_Position = camera * vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要在C++代码中设置<code>camera</code>着色器变量。在<code>LoadShaders</code>函数的地步，我们添加这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gProgram-&gt;use();</span><br><span class="line"></span><br><span class="line">glm::mat4 camera = glm::lookAt(glm::vec3(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>), glm::vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">gProgram-&gt;setUniform(<span class="string">"camera"</span>, camera);</span><br><span class="line"></span><br><span class="line">gProgram-&gt;stopUsing();</span><br></pre></td></tr></table></figure><p>这个相机矩阵在本文中不会再被改变，当所有着色器被创建后，我们只需这样设置一次。</p><p>你无法在设置着色器变量，除非着色器在使用中，这就是为何我们用到了<code>gProgram-&gt;use()</code>和<code>gProgram-&gt;stopUsing()</code>。</p><p>我们使用<code>glm::lookAt</code>函数为我们创建相机矩阵。假如你使用的是旧版本的OpenGL，那你应该使用<code>gluLookAt</code>函数来达到相同目的，但<code>gluLookAt</code>已经在最近的OpenGL版本中被移除了。第一个参数<code>glm::vec3(3,3,3)</code>是相机的位置。第二个参数<code>glm::vec3(0,0,0)</code>是相机观察的点。立方体中心是（0,0,0），相机就朝着这个点观察。最后一个参数<code>glm::vec3(0,1,0)</code>是“向上”的方向。我们需要垂直摆放相机，所以我们设置“向上”是沿着Y轴的正方向。假如相机是颠倒或者倾斜的，这里就是其它值了。</p><p>在我们生成了相机矩阵后，我们用<code>gProgram-&gt;setUniform(&quot;camera&quot;, camera);</code>来设置<code>camera</code>着色器变量，<code>setUniform</code>方法属于<code>tdogl::Program</code>类，它会调用<code>glUniformMatrix4fv</code>来设置变量。</p><p>就是这样！我们现在有了一个可运行的相机。</p><p>不幸的是，假如你现在运行程序，你会看到整个都是黑屏。因为我们的立方体顶点经过相机矩阵变换后，飞出了裁剪体。这就是上面我提到的，在裁剪体之外的它是不会被显示。为了能再次看到它，我们需要设置<strong>投影矩阵</strong>。</p><h2 id="实现投影矩阵"><a href="#实现投影矩阵" class="headerlink" title="实现投影矩阵"></a>实现投影矩阵</h2><p>记住裁剪体只有2个单元宽、高和深。假设1个单元等于我们3D场景中的1米。这就意味着我们在相机中能看到正前方2米，这样不是很方便。</p><p>我们需要扩大裁剪体使得能看到3D场景中的更多东西，可怜我们又不能改变裁剪体的大小，但，我们能缩小整个场景。缩小是一个变换，所以我们用矩阵来表示，基本上说，投影矩阵就是用来干这个的。</p><p>让我们在顶点着色器中加入投影矩阵变量。更新后的代码看上去是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line"></span><br><span class="line">uniform mat4 projection; <span class="comment">//this is the new variable</span></span><br><span class="line">uniform mat4 camera;</span><br><span class="line"></span><br><span class="line">in vec3 vert;</span><br><span class="line">in vec2 vertTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the tex coord straight through to the fragment shader</span></span><br><span class="line">    fragTexCoord = vertTexCoord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply camera and projection transformations to the vertex</span></span><br><span class="line">    gl_Position = projection * camera * vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意矩阵相乘的顺序：<code>projection * camera * vert</code>。相机变换是放在首位的，投影矩阵是第二位。<mark>矩阵乘法中，变换从右往左，从顶点角度说是从最近的变换到更早前的变换。</mark></p><p>现在让我们在C++代码中设置<code>projection</code>着色器变量，方式和我们设置<code>camera</code>变量相同。在<code>LoadShaders</code>函数中，添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection = glm::perspective(glm::radians(<span class="number">50.0f</span>), SCREEN_SIZE.x/SCREEN_SIZE.y, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line">gProgram-&gt;setUniform(<span class="string">"projection"</span>, projection);</span><br></pre></td></tr></table></figure><p>假如你使用的是旧版本OpenGL，你可以使用<code>gluPerspective</code>来设置投影矩阵，同样<code>gluPerspective</code>函数在最近版本的OpenGL中也被移除了。幸运的是你可以使用<code>glm::perspective</code>来替代。</p><p><code>glm::perspective</code>第一个参数是“可视区域”参数。这个参数是个弧度，用来说明相机视野有多宽。弧度换算我们可以用<code>glm::radians</code>函数来将50度转换为弧度。大的可视区域意味着我们的相机可以看到更多场景，看上去就像是缩小了。小的可视区域意味着相机只能看到场景的一小部分，看上去像是放大了。第二个参数是“纵横比”，该参数表示可视区域的纵横比率。一般该参数设置为窗口的<code>width/height</code>，倒数第二个参数是“近平面”，近平面是裁剪体的前面，<code>0.1</code>表示近平面离相机是0.1单位远。任何离相机小于<code>0.1</code>单位的物体均不可见。近平面的值必须大于0。最后一个参数是“远平面”，远平面是裁剪体的后面。<code>10.0</code>表示相机所显示的物体均离相机10个单位之内。任何大于10单位的物体均不可见。我们的立方体是3单位远，所以它能被看见。</p><p><code>glm::perspective</code>对将<a href="http://en.wikipedia.org/wiki/Viewing_frustum&quot;" target="_blank" rel="noopener">可视锥体</a>对应到裁剪体中非常有用。一个锥体像是一个金字塔被砍掉了顶端。金字塔的底部就是远平面，顶部就是近平面。可视区域就是该锥体胖瘦。任何在锥体里的物体都会被显示，而不再内的就隐藏。</p><p><img src="/static/img/opengl-tutorials/frustum.png" alt=""></p><p>有了相机矩阵和投影矩阵的组合，我们就可以看到立方体了。运行程序你会看到：</p><p><img src="/static/img/opengl-tutorials/depth-buffer-disabled.png" alt=""></p><p>这看上去。。。几乎是对的。</p><p>这个立方体看上去已经是正方形了，不再是矩形。这是因为<code>glm::perspective</code>中的“纵横比”参数，能够基于窗口的宽和高进行正确的调整比例。</p><p>不幸的是，截图看上去立方体的背面渲染并覆盖到前面来了。我们当然不希望发生这样的事，我们需要开启<strong>深度缓冲</strong>来解决。</p><h2 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h2><p>OpenGL默认会将最新的绘制覆盖到之前的绘制上。假如一个物体的背面在前面之后绘制，就会发生背面挡住前面。<mark>深度缓冲就是为了防止背景层覆盖到前景层的东西。</mark></p><p>假如深度缓冲被开启，每个被绘制的像素到相机的距离都是可知的。这个距离会以一个数值保存在深度缓冲里。当你绘制一个像素在另外一个已存在的像素上时，OpenGL会查找深度缓冲来决定哪个像素应该离相机更近。假如新的像素离相机更近，那该像素点就会被重写。假如之前的像素离相机更近，那新像素就会被<em>抛弃</em>。所以，<mark>一个之前已存在的像素只会当新像素离相机更近时才会被重写。</mark>这就叫做“深度测试”。</p><h2 id="实现深度缓冲"><a href="#实现深度缓冲" class="headerlink" title="实现深度缓冲"></a>实现深度缓冲</h2><p>在<code>AppMain</code>函数中，调用了<code>glewInit</code>之后，我们添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDepthFunc(GL_LESS);</span><br></pre></td></tr></table></figure><p>这告诉OpenGL开启深度测试。调用<code>glDepthFunc</code>是表明假如像素离相机的距离<em>小于</em>之前的像素距离时应该被重写。</p><p>最后一步我们需要在渲染每帧之后清理深度缓冲。假如我们不清理，旧的像素距离会保存在缓冲中，这样会影响到绘制新的一帧。在<code>Render</code>函数里，我们改变<code>glClear</code>来实现它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p><img src="/static/img/opengl-tutorials/depth-buffer-correct.png" alt=""></p><h2 id="旋转立方体"><a href="#旋转立方体" class="headerlink" title="旋转立方体"></a>旋转立方体</h2><p>假如你完成了上述例子，祝贺你走了这么远！最后我们来实现会旋转的立方体动画。</p><p>如何实现旋转？你会猜到：另外一个矩阵。这与之前的矩阵不同的是，这个矩阵是每帧都在改变，之前的矩阵都是常量。</p><p>我需要新建一个“模型”矩阵。在常见的3D引擎中，每个物体都有一个模型矩阵。相机和投影矩阵对整个场景来说是一样的，但模型矩阵是每个物体都不同。模型矩阵用来摆放每个物体在正确的位置上（平移），设置正确的面向（旋转），或者改变物体大小（缩放）。我们只有一个物体在当前3D场景上，所以，我们只需要一个模型矩阵。</p><p>让我们添加一个<code>model</code>矩阵变量到顶点着色器，就像我们添加相机和投影一样。最终版本的顶点着色器应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 camera;</span><br><span class="line">uniform mat4 model; <span class="comment">//this is the new variable</span></span><br><span class="line"></span><br><span class="line">in vec3 vert;</span><br><span class="line">in vec2 vertTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the tex coord straight through to the fragment shader</span></span><br><span class="line">    fragTexCoord = vertTexCoord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply all matrix transformations to vert</span></span><br><span class="line">    gl_Position = projection * camera * model * vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是要注意矩阵相乘的顺序。模型矩阵是<code>vert</code>变量最近的一次变换，意味着模型矩阵应该第一个被使用，其次是相机，最后是投影。</p><p>现在我们需要设置新的<code>model</code>着色器变量。不像相机和投影变量，模型变量需要每帧都被设置，所以我们把它放在<code>Render</code>函数里。在<code>gProgram-&gt;use()</code>之后添加这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gProgram-&gt;setUniform(<span class="string">"model"</span>, glm::rotate(glm::mat4(), glm::radians(<span class="number">45.0f</span>), glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>我们使用<code>glm::rotate</code>函数创建一个旋转矩阵。第一个参数是一个已存在的需要进行旋转的矩阵。在这我们不需要对已存在的矩阵进行旋转，所以我们传个新的<code>glm::mat4</code>对象就可以了。下一个参数是旋转的角度，或者说是要旋转多少度。现在让我给它设置个45°。最后一个参数是旋转的轴。想象下旋转像是将物体插在叉子上，然后转动叉子。叉子就是轴，角度就是你的转动。在我们的例子中，我们使用垂直的叉子，所以立方体像在一个平台上旋转。</p><p>运行程序，你们看到立方体被旋转：</p><p><img src="/static/img/opengl-tutorials/not-animated.png" alt=""></p><p>它还没有转动，因为矩阵没有被更改-它永远是旋转了45°。最后一步就是让它每帧都旋转一下。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>首先，添加一个新的全局变量叫<code>gDegreesRotated</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLfloat gDegreesRotated = <span class="number">0.0f</span>;</span><br></pre></td></tr></table></figure><p>每帧，我们会轻微的增加<code>gDegreesRotated</code>，并且我们用它来计算新的旋转矩阵。这样就能达到动画效果。我们需要做的就是更新，绘制，更新，绘制，更新，绘制，这样一个模式。</p><p>让我们创建一个<code>Update</code>函数，用来每次增加<code>gDegreesRotated</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//rotate by 1 degree</span></span><br><span class="line">    gDegreesRotated += <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//don't go over 360 degrees</span></span><br><span class="line">    <span class="keyword">while</span>(gDegreesRotated &gt; <span class="number">360.0f</span>) gDegreesRotated -= <span class="number">360.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要每帧都调用一次<code>Update</code>函数。让我们把它加入到<code>AppMain</code>的循环中，在调用<code>Render</code>之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(glfwGetWindowParam(GLFW_OPENED))&#123;</span><br><span class="line">    <span class="comment">// process pending events</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the rotation animation</span></span><br><span class="line">    Update();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw one frame</span></span><br><span class="line">    Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要基于<code>gDegreesRotated</code>变量来重新计算模型矩阵。在<code>Render</code>函数中我们修改相关代码来设置模型矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gProgram-&gt;setUniform(<span class="string">"model"</span>, glm::rotate(glm::mat4(), glm::radians(gDegreesRotated), glm::vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>与之前唯一不同的是我们使用了<code>gDegreesRotated</code>来替换45°常量。</p><p>你现在运行程序能看到一个漂亮，平滑转动的立方体动画。唯一的问题就是转动的速度很你的FPS帧率有关。假如FPS高，你的立方体旋转的就快。假如FPS降低，那立方体旋转的就慢些。这不够理想。一个程序应该能正确更新，而不在乎于运行的帧率。</p><h2 id="基于时间的动画"><a href="#基于时间的动画" class="headerlink" title="基于时间的动画"></a>基于时间的动画</h2><p>为了使程序跑起来更正确，不依赖于FPS，动画应该<em>每秒</em>更新，而非<em>每帧</em>更新。最简单得方式就是对时间进行计数，并相对上次更新时间来正确更新。让我们改下<code>Update</code>函数，增加个变量<code>secondsElapsed</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> secondsElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> GLfloat degreesPerSecond = <span class="number">180.0f</span>;</span><br><span class="line">    gDegreesRotated += secondsElapsed * degreesPerSecond;</span><br><span class="line">    <span class="keyword">while</span>(gDegreesRotated &gt; <span class="number">360.0f</span>) gDegreesRotated -= <span class="number">360.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使得立方体每秒旋转180°，而无关多少帧率。</p><p>在<code>AppMain</code>循环中，我们需要计算离上次更新过去了多少秒。新的循环应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> lastTime = glfwGetTime();</span><br><span class="line"><span class="keyword">while</span>(glfwGetWindowParam(GLFW_OPENED))&#123;</span><br><span class="line">    <span class="comment">// process pending events</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the scene based on the time elapsed since last update</span></span><br><span class="line">    <span class="keyword">double</span> thisTime = glfwGetTime();</span><br><span class="line">    Update((<span class="keyword">float</span>)(thisTime - lastTime));</span><br><span class="line">    lastTime = thisTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw one frame</span></span><br><span class="line">    Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>glfwGetTime</code>返回从程序启动开始到现在所逝去的时间。</p><p>我们使用<code>lastTime</code>变量来记录上次更新时间。每次迭代，我们获取最新的时间存入变量<code>thisTime</code>。从上次更新到现在的差值就是<code>thisTime - lastTime</code>。当更新结束，我们设置<code>lastTime = thisTime</code>以便下次循环迭代的时候很正常工作。</p><p>这是基于时间更新的最简单方法。这里还有<a href="http://gafferongames.com/game-physics/fix-your-timestep/" target="_blank" rel="noopener">更好的更新方法</a>，但我们还不需要搞得这么复杂。</p><h2 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h2><p>下一篇，我们会使用<code>tdogl::Camera</code>类来实现用键盘操作第一人称射击类型的相机移动，可以用鼠标观察不同方向，或者用鼠标滚轮来放大缩小。</p><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul><li><a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/" target="_blank" rel="noopener">Tutorial 3 : Matrices</a> is a great explanation of matrices from opengl-tutorial.org</li><li><a href="http://en.wikipedia.org/wiki/Scaling_(geometry" target="_blank" rel="noopener">Scaling</a>), <a href="http://en.wikipedia.org/wiki/Rotation_matrix" target="_blank" rel="noopener">rotation</a>, <a href="http://en.wikipedia.org/wiki/Translation_(geometry" target="_blank" rel="noopener">translation</a>), and <a href="http://en.wikipedia.org/wiki/Transformation_matrix" target="_blank" rel="noopener">transformation matrices</a> on Wikipedia</li><li><a href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices" target="_blank" rel="noopener">Basic 3D Math: Matrices</a></li><li><a href="http://www.teamten.com/lawrence/graphics/homogeneous/" target="_blank" rel="noopener">Homogeneous coordinates</a> by Lawrence Kesteloot</li><li><a href="http://www.glprogramming.com/red/chapter03.html" target="_blank" rel="noopener">Viewing</a> chapter of the OpenGL red book. Uses old version of OpenGL in code examples, but the theory is still the same.</li><li>GLM <a href="http://glm.g-truc.net/code.html" target="_blank" rel="noopener">code samples</a> and <a href="http://glm.g-truc.net/glm-0.9.4.pdf" target="_blank" rel="noopener">manual (pdf)</a></li><li><a href="http://en.wikipedia.org/wiki/Z-buffering" target="_blank" rel="noopener">Z-buffering (depth buffering)</a> on Wikipedia</li><li><a href="http://www.arcsynthesis.org/gltut/Positioning/Tut05%20Overlap%20and%20Depth%20Buffering.html" target="_blank" rel="noopener">Overlap and Depth Buffering</a> section of the Learning Modern 3D Graphics Programming book</li><li><a href="http://gafferongames.com/game-physics/fix-your-timestep/" target="_blank" rel="noopener">Fix Your Timestep!</a> by Glenn Fiedler</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/static/img/opengl-tutorials/modern-opengl-03.png&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文中，我会将不会动的2D三角形替换为旋转的3D立方体。你会看到这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/img/opengl-tutorials/rotating-crate.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们终于能在屏幕上搞点有趣的东西了，我放了更多的动图在这里：&lt;a href=&quot;http://imgur.com/a/x8q7R&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://imgur.com/a/x8q7R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了生成旋转立方体，我们需要学些关于矩阵的数学，用于创建透视投影，旋转，平移和“相机”概念。我们还有必要学习些深度缓冲，和典型的随时间改变的3D应用，比如动画。&lt;/p&gt;
    
    </summary>
    
      <category term="modern-opengl-tutorials" scheme="http://huangwei.pro/categories/modern-opengl-tutorials/"/>
    
    
      <category term="opengl" scheme="http://huangwei.pro/tags/opengl/"/>
    
      <category term="tutorials" scheme="http://huangwei.pro/tags/tutorials/"/>
    
  </entry>
  
  <entry>
    <title>视线和光线：如何给游戏添加 2D 可见性和阴影效果</title>
    <link href="http://huangwei.pro/2015-08/game-sight-light/"/>
    <id>http://huangwei.pro/2015-08/game-sight-light/</id>
    <published>2015-08-10T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.562Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/89193/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>各位好！今天，我将告诉你如何做这样的事情：（在框中四处移动你的鼠标）</p><iframe src="http://ncase.me/sight-and-light/draft7.html" height="370" width="850"></iframe><p>这种效果用于我新开发的开源游戏《<a href="http://nothingtohide.cc/" target="_blank" rel="noopener">Nothing To Hide</a>》。许多其他的 2D 游戏（如Monaco，Gish）也都有。如果按着本教程来实现……也许下个就是你的游戏！</p><a id="more"></a><p><img src="http://ww4.sinaimg.cn/large/7cc829d3gw1eux6hz1uofj20nc06y3zz.jpg" alt=""></p><p>我将展示我在学习如何实现这种效果过程中的步骤和所发生的错误。首先，给一些样板代码。下面只是演示绘制了一堆线段并跟踪鼠标位置。（注：有四个线段为边框）</p><iframe src="http://ncase.me/sight-and-light/draft0.html" height="370" width="650"></iframe><p>接下来介绍数学知识。别担心，这里只是复习下入门的代数而已。</p><p>我们需要找出射线和所有线段的最近交叉点。任何线段可以被写成参数形式：</p><pre class="brush: c; gutter: false">点 + 方向 * T</pre><p>这儿我们给出 4 组方程来描述射线和线段的 x 和 y 变量：</p><pre class="brush: c; gutter: false">射线 X = r_px+r_dx*T1射线 Y = r_py+r_dy*T1线段 X = s_px+s_dx*T2线段 Y = s_py+s_dy*T2</pre><p>注：在我们做任何事情之前，请检查以确保射线和线段不是平行的，也就是说，它们的方向是不一样的。如果它们是平行的，那就没有交集。好了，继续。</p><p>如果射线和线段相交，其 x 和 y 变量是相同的：</p><pre class="brush: c; gutter: false">r_px+r_dx*T1 = s_px+s_dx*T2r_py+r_dy*T1 = s_py+s_dy*T2</pre><p>我们做个小小的符号移位来求解 T1 和 T2</p><pre class="brush: c; gutter: false">// Isolate T1 for both equations, getting rid of T1// 从两个等式中独立出T1，移去T1 T1 = (s_px+s_dx*T2-r_px)/r_dx = (s_py+s_dy*T2-r_py)/r_dy// Multiply both sides by r_dx * r_dy// 两边同乘上 r_dx * r_dys_px*r_dy + s_dx*T2*r_dy - r_px*r_dy = s_py*r_dx + s_dy*T2*r_dx - r_py*r_dx// Solve for T2!// 解出T2！T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx)// Plug the value of T2 to get T1// 代入T2，解出T1T1 = (s_px+s_dx*T2-r_px)/r_dx</pre><p>确保 T1&gt;0 并且 0&lt;T2&lt;1。如果不是，则可认为射线和线段没有交点，不可能有交集。但如果是，那太好了！你已经找到了一个交点。现在只要使用同一条射线与其它线段进行计算，就能找到最近的交点。（这个值就是最小T1值）</p><p>这就是所有的数学知识了：（将鼠标移到下面的框里）</p><iframe src="http://ncase.me/sight-and-light/draft1.html" height="370" width="650"></iframe><p>哇！现在用这些东西让我们找一些乐子！我投了50条向各个方向的光线：</p><iframe src="http://ncase.me/sight-and-light/draft2.html" height="370" width="650"></iframe><p>于是我想，我可以简单地连接这些射线与线段的点，就能获得不错的可见性多边形。但是，最终它看起来像……</p><iframe src="http://ncase.me/sight-and-light/draft3.html" height="370" width="650"></iframe><p>织网。但这并不重要，即使我使用360条射线来模拟360度，它仍然看上去很不靠谱。这是我最大的绊脚石，直到我意识到我不可能四面八方都投射到。我只需投射到线段的两端点。对每一个（唯一的）线段端点，朝它直接投射射线，再加上两条偏移为+/- 0.00001弧度的射线。这两条额外的射线会打在给定线段后面的墙上。</p><iframe src="http://ncase.me/sight-and-light/draft4.html" height="370" width="650"></iframe><p>接下来，按照射线的角度对交点进行排序。这让我可以简单地按顺时针方向连接各个点，并绘制出平滑的可见性多边形，比如这样的：</p><iframe src="http://ncase.me/sight-and-light/draft5.html" height="370" width="650"></iframe><p>终于来了！为了实际上看起来更好些。为了绘制额外的可见性多边形，我们再在位置上稍微偏移投射射线，可以创造出“模糊”阴影，像下面一样。红点表示11原点 - 是的，这有11个可见性多边形！</p><iframe src="http://ncase.me/sight-and-light/draft6.html" height="370" width="650"></iframe><p>当这一切完成后，我画了这两张图像…</p><p><img src="http://ww4.sinaimg.cn/large/7cc829d3gw1eux6hyagcuj20nc0a0mxi.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/7cc829d3gw1eux6hxmtltj20nc0a0t98.jpg" alt=""></p><p>…并混合在一起，利用模糊阴影作为一个alpha遮罩。我已经向您展示了跟页面顶部相似的令人毛骨悚然的画面，只不过这里是一个不同的迭代，用了多个光源。</p><iframe src="http://ncase.me/sight-and-light/draft8.html" height="370" width="850"></iframe><p>多个光源。投射阴影。一个巨大的激光炸弹。显示出你的主角/敌人看的到或看不到的区域。2D可见性/照明效果可以非常灵活得进行合适的创意，可以为您的游戏增加很多额外的魅力。</p><h3 id="要有光"><a href="#要有光" class="headerlink" title="要有光"></a>要有光</h3><p>*完全是一个技术术语 （译者注：原本是圣经创世纪里的一句话）</p><p>作者的开源地址：<a href="https://github.com/ncase/sight-and-light" target="_blank" rel="noopener">https://github.com/ncase/sight-and-light</a></p>]]></content>
    
    <summary type="html">
    
      视线和光线：如何给游戏添加 2D 可见性和阴影效果
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="game" scheme="http://huangwei.pro/tags/game/"/>
    
      <category term="2d" scheme="http://huangwei.pro/tags/2d/"/>
    
      <category term="visibility" scheme="http://huangwei.pro/tags/visibility/"/>
    
      <category term="sight" scheme="http://huangwei.pro/tags/sight/"/>
    
  </entry>
  
  <entry>
    <title>现代OpenGL教程 02 - 贴图</title>
    <link href="http://huangwei.pro/2015-08/modern-opengl2/"/>
    <id>http://huangwei.pro/2015-08/modern-opengl2/</id>
    <published>2015-08-05T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/static/img/opengl-tutorials/modern-opengl-02.png" width="60%"></p><p>在本文中，我们将给三角形加一个贴图，这需要在顶点和片段着色器中加入一些新变量，创建和使用贴图对象，并且学习一点贴图单元和贴图坐标的知识。</p><p>本文会使用两个新的类到<code>tdogl</code>命名空间中：<code>tdogl:Bitmap</code>和<code>tdogl:Texture</code>。这些类允许我们将jpg，png或bmp图片上传到显存并用于着色器。<code>tdogl:Program</code>类也增加一些相关接口。</p><a id="more"></a><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>所有例子代码的zip打包可以从这里获取：<a href="https://github.com/tomdalling/opengl-series/archive/master.zip" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series/archive/master.zip</a>。</p><p>这一系列文章中所使用的代码都存放在：<a href="https://github.com/tomdalling/opengl-series" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series</a>。你可以在页面中下载zip，加入你会git的话，也可以复制该仓库。</p><p>本文代码你可以在<code><a href="https://github.com/tomdalling/opengl-series/tree/master/source/02_textures" target="_blank" rel="noopener">source/02_textures</a></code>目录里找到。使用OS X系统的，可以打开根目录里的<code>opengl-series.xcodeproj</code>，选择本文工程。使用Windows系统的，可以在Visual Studio 2013里打开<code>opengl-series.sln</code>，选择相应工程。</p><p>工程里已包含所有依赖，所以你不需要再安装或者配置额外的东西。如果有任何编译或运行上的问题，请联系我。</p><h2 id="着色器变量Uniform与Attribute"><a href="#着色器变量Uniform与Attribute" class="headerlink" title="着色器变量Uniform与Attribute"></a>着色器变量Uniform与Attribute</h2><p>教程一里的着色器变量都是<em>attribute</em>，本文介绍另外一种类型的变量：<em>uniform</em>变量。</p><p>着色器变量有两种类型：<em>uniform</em>和<em>attribute</em>。<mark><em>attribute</em>变量可以在每个顶点上有不同值。而<em>uniform</em>变量在多个顶点上保持相同值。</mark>比如，你想要给一个三角形设置一种颜色，那你应该使用<em>uniform</em>变量，如果你希望每个三角形顶点有不同颜色，你应该使用<em>attribute</em>变量。从这开始，我称呼他们为“uniforms”和“attributes”。</p><p><mark>Uniforms能被任意着色器访问，但是Attributes必须先进入<strong>顶点着色器</strong>，而非<strong>片段着色器</strong>。顶点着色器在需要时会将该值传给片段着色器。</mark>这因为Uniforms像常量-它们不会被任何着色器更改。然而，Attributes不是常量。顶点着色器会改变Attribute变量的值，在片段着色器获取之前。就是说，顶点着色器的输出就是片段着色器的输入。</p><p>为了设置Uniform的值，我们可以调用<a href="http://www.opengl.org/sdk/docs/man/xhtml/glUniform.xml" target="_blank" rel="noopener">glUniform*</a>系列函数。而设置Attribute的值，我们需要在VBO中保存，并且和VAO一起发送给着色器，就像前一篇教程里的<a href="http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttribPointer.xml" target="_blank" rel="noopener">glVertexAttribPointer</a>。加入你不想把值存在VBO里，你也可以使用<a href="http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttrib.xml" target="_blank" rel="noopener">glVertexAttrib*</a>系列函数来设置Attribute值。</p><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p><mark>贴图，大体上来说就是你应用在3D物体上的2D图像。</mark>它有其它用途，但显示2D图像在3D几何上是最常用的。有1D，2D，3D贴图，但本文只讲2D贴图。更深入阅读，请参见<a href="http://www.arcsynthesis.org/gltut/" target="_blank" rel="noopener">Learning Modern 3D Graphics Programming</a>书中的<a href="http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2014.html" target="_blank" rel="noopener">Textures are not Pictures</a>章节。</p><p>贴图是存放在显存里的。那就是说，你需要在使用之前上传你的贴图数据给显卡。这类似VBO在前文的作用-VBO也是在使用之前需要存放到显存上。</p><p><mark>贴图的高和宽需要是2的幂次方。</mark>比如16，32，64，128，256，512。本文中使用的是256*256的图像作为贴图，如下图所示。</p><p><img src="/static/img/opengl-tutorials/hazard.png" alt="hazard.png"></p><p>我们使用<code>tdogl:Bitmap</code>来加载“hazard.png”的原始像素数据到内存中，参见<a href="https://github.com/nothings/stb" target="_blank" rel="noopener">stb_image</a>帮助文档。然后我们使用<code>tdogl:Texture</code>上传原始像素数据给OpenGL贴图对象。幸运的是OpenGL中的贴图创建方法从面世到现在都没有实质性的变化，所以网上有大量的创建贴图的好文章。虽然贴图坐标的传输方式有变化，但创建贴图还是跟以前一样。</p><p>以下是<code>tdogl:Texture</code>的构造函数，用于OpenGL贴图创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Texture::Texture(<span class="keyword">const</span> Bitmap&amp; bitmap, GLint minMagFiler, GLint wrapMode) :</span><br><span class="line">    _originalWidth((GLfloat)bitmap.width()),</span><br><span class="line">    _originalHeight((GLfloat)bitmap.height())</span><br><span class="line">&#123;</span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;_object);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, _object);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minMagFiler);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, minMagFiler);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">                 <span class="number">0</span>, </span><br><span class="line">                 TextureFormatForBitmapFormat(bitmap.format()),</span><br><span class="line">                 (GLsizei)bitmap.width(), </span><br><span class="line">                 (GLsizei)bitmap.height(),</span><br><span class="line">                 <span class="number">0</span>, </span><br><span class="line">                 TextureFormatForBitmapFormat(bitmap.format()), </span><br><span class="line">                 GL_UNSIGNED_BYTE, </span><br><span class="line">                 bitmap.pixelBuffer());</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贴图坐标"><a href="#贴图坐标" class="headerlink" title="贴图坐标"></a>贴图坐标</h2><p>毫无疑问，贴图坐标就是贴图上的坐标。<mark>关于贴图坐标比较奇特的是它们不是以像素为单位。它们范围是从0到1，(0, 0)是左下角，(1, 1)是右上角。</mark>假如你上传到OpenGL的图像是颠倒的，那(0, 0)就是左上角，而非左下角。将像素坐标转换为贴图坐标，你必须除上贴图的宽和高。比如，在256*256的图像中，像素坐标(128, 256)的贴图坐标是(0.5, 1)。</p><p><img src="/static/img/opengl-tutorials/uv_coords.png" alt="uv_coords.png"></p><p>贴图坐标通常被称为UV坐标。你也可以叫它们是XY坐标，但是XYZ通常被用来表示顶点，我们不希望将这两者混淆。</p><h2 id="贴图图像单元"><a href="#贴图图像单元" class="headerlink" title="贴图图像单元"></a>贴图图像单元</h2><p>贴图图像单元，亦或简称“贴图单元”，是在OpenGL中略怪异的一部分。<mark>你无法直接发送贴图给着色器。首先，你要绑定贴图到贴图单元，然后呢要发送<strong>贴图单元的索引</strong>给着色器</mark></p><p>对于贴图单元是有数量限制的。在低端硬件上，如手机，它们只有两个贴图单元。既然如此，即使我们有许多的贴图，我们也只能同时使用两个贴图单元在着色器中。我们在本文中只用到了一个贴图，所以也只需要一个贴图单元，但它可以在多个不同的着色器中混合。</p><h2 id="实现贴图"><a href="#实现贴图" class="headerlink" title="实现贴图"></a>实现贴图</h2><p>首先，让我们创建一个新的全局贴图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tdogl::Texture* gTexture = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>我们为加载“hazard.png”图片新增一个函数。该函数能被<code>AppMain</code>所调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tdogl::Bitmap bmp = tdogl::Bitmap::bitmapFromFile(ResourcePath(<span class="string">"hazard.png"</span>));</span><br><span class="line">    bmp.flipVertically();</span><br><span class="line">    gTexture = <span class="keyword">new</span> tdogl::Texture(bmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步，我们给每个三角形的顶点一个贴图坐标。假如你跟上图比较过UV坐标，就可以看出按顺序这个坐标表示（中，上），（左，下）和（右，下）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertexData[] = &#123;</span><br><span class="line">    <span class="comment">//  X     Y     Z       U     V</span></span><br><span class="line">     <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.0f</span>,   <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们需要修改片段着色器，使得它能使用贴图和贴图坐标作为输入。下面是新的片段着色器代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line">uniform sampler2D tex; <span class="comment">//this is the texture</span></span><br><span class="line">in vec2 fragTexCoord; <span class="comment">//this is the texture coord</span></span><br><span class="line">out vec4 finalColor; <span class="comment">//this is the output color of the pixel</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalColor = texture(tex, fragTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniform</code>关键字说明<code>tex</code>是<em>uniform</em>变量。贴图是一致的，因为所有三角形顶点有相同的贴图。<code>sampler2D</code>是变量类型，说明它包含一个2D贴图。</p><p><code>fragTexCoord</code>是<em>attribute</em>变量，因为每个三角形顶点是不同的贴图坐标。</p><p><code>texture</code>函数是用来查找给定贴图坐标的像素颜色。在GLSL旧版本中，你应该使用<code>texture2D</code>函数来实现该功能。</p><p>我们无法直接传送<em>attribute</em>给判断着色器，因为<em>attribute</em>必须首先通过顶点着色器。这儿是修改过的顶点着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 150</span></span><br><span class="line">in vec3 vert;</span><br><span class="line">in vec2 vertTexCoord;</span><br><span class="line">out vec2 fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the tex coord straight through to the fragment shader</span></span><br><span class="line">    fragTexCoord = vertTexCoord;</span><br><span class="line">    </span><br><span class="line">    gl_Position = vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点着色器使用<code>vertTexCoord</code>作为输入，并且将它不经修改，直接传给名为<code>fragTexCoord</code>的<em>attribute</em>片段着色器变量。</p><p>着色器有两个变量需要我们设置：<code>vertTexCoord</code><em>attribute</em>变量和<code>tex</code><em>uniform</em>变量。让我们从设置<code>tex</code>变量开始。打开main.cpp，找到<code>Render()</code>函数。我们在绘制三角形之前设置<code>tex</code><em>uniform</em>变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, gTexture-&gt;object());</span><br><span class="line">gProgram-&gt;setUniform(<span class="string">"tex"</span>, <span class="number">0</span>); <span class="comment">//set to 0 because the texture is bound to GL_TEXTURE0</span></span><br></pre></td></tr></table></figure><p>贴图在没有绑定到贴图单元时，是无法使用的。<code>glActiveTexture</code>告诉OpenGL我们希望使用哪个贴图单元。<code>GL_TEXTURE0</code>是第一个贴图单元，我们就使用它。</p><p>下一本，我们使用<code>glBindTexture</code>来绑定我们的贴图到激活的贴图单元。</p><p>然后我们设置贴图单元索引给<code>tex</code><em>uniform</em>着色器变量。我们使用0号贴图单元，所以我们设置<code>tex</code>变量为整数<code>0</code>。<code>setUniform</code>方法只是调用了<code>glUnifrom1i</code>函数。</p><p>最后一步，获取贴图坐标给<code>vertTexCoord</code><em>attribute</em>变量。为了实现它，我们需要修改<code>LoadTriangle()</code>函数中的VAO。之前的代码是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put the three triangle vertices into the VBO</span></span><br><span class="line">GLfloat vertexData[] = &#123;</span><br><span class="line">    <span class="comment">//  X     Y     Z</span></span><br><span class="line">     <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect the xyz to the "vert" attribute of the vertex shader</span></span><br><span class="line">glEnableVertexAttribArray(gProgram-&gt;attrib(<span class="string">"vert"</span>));</span><br><span class="line">glVertexAttribPointer(gProgram-&gt;attrib(<span class="string">"vert"</span>), <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>现在我们需要改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put the three triangle vertices (XYZ) and texture coordinates (UV) into the VBO</span></span><br><span class="line">GLfloat vertexData[] = &#123;</span><br><span class="line">    <span class="comment">//  X     Y     Z       U     V</span></span><br><span class="line">     <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.0f</span>,   <span class="number">0.5f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect the xyz to the "vert" attribute of the vertex shader</span></span><br><span class="line">glEnableVertexAttribArray(gProgram-&gt;attrib(<span class="string">"vert"</span>));</span><br><span class="line">glVertexAttribPointer(gProgram-&gt;attrib(<span class="string">"vert"</span>), <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span>*<span class="keyword">sizeof</span>(GLfloat), <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// connect the uv coords to the "vertTexCoord" attribute of the vertex shader</span></span><br><span class="line">glEnableVertexAttribArray(gProgram-&gt;attrib(<span class="string">"vertTexCoord"</span>));</span><br><span class="line">glVertexAttribPointer(gProgram-&gt;attrib(<span class="string">"vertTexCoord"</span>), <span class="number">2</span>, GL_FLOAT, GL_TRUE,  <span class="number">5</span>*<span class="keyword">sizeof</span>(GLfloat), (<span class="keyword">const</span> GLvoid*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat)));</span><br></pre></td></tr></table></figure><p>我们第二次调用了<code>glVertexAttribPointer</code>，但我们也修改了第一个调用。最重要的是最后两个参数。</p><p>两个<code>glVertexAttribPointer</code>调用的倒数第二个参数都是<code>5*sizeof(GLfloat)</code>。这是“步长”参数。该参数是表明每个值开始位置的间隔是多少字节，或者说是到下个值开始的字节数。在两个调用中，每个值是5个<code>GLFloat</code>长度。举个例子，加入我们从“X”开始，往前数5个值，我们会落在下个“X”值上。从“U”开始也一样，也是往前数5个。该参数是字节单位，不是浮点作为单位，所以我们必须乘上浮点类型所占字节数。</p><p>最后一个参数<code>glVertexAttribPointer</code>是一个“偏移”参数。该参数需要知道从开始到第一个值有多少字节。开始是<strong>XYZ</strong>，所以偏移设置为NULL表示“到开始的距离为0字节”。第一个<strong>UV</strong>不在最前面-中间有3个浮点的距离。再说一遍，参数是以字节为单位，而非浮点，所以我们必须乘上浮点类型所占字节数。并且我们必须将数值转为<code>const GLvoid*</code>类型，因为在旧版本的OpenGL中该参数有别于现在的“偏移”。</p><p>现在，当你运行程序，你就能看到如本文最上方的那个三角形。</p><h2 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h2><p>下一篇教程中我们会学一些矩阵相关的东西，使用矩阵来旋转立方体，移动相机，和添加透视投影。我们还会学习深度缓冲和基于时间更新的逻辑，比如动画。</p><h2 id="更多OpenGL贴图相关资源"><a href="#更多OpenGL贴图相关资源" class="headerlink" title="更多OpenGL贴图相关资源"></a>更多OpenGL贴图相关资源</h2><ul><li><a href="http://www.opengl.org/wiki/Texture" target="_blank" rel="noopener">The texture page on the OpenGL wiki</a></li><li><a href="http://www.arcsynthesis.org/gltut/Texturing/Texturing.html" target="_blank" rel="noopener">The texturing chapters</a> of the Learning Modern 3D Graphics Programming book.</li><li><a href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html" target="_blank" rel="noopener">Tutorial 16 - Basic Texture Mapping</a> by Etay Meiri</li><li><a href="https://github.com/progschj/OpenGL-Examples/blob/master/03texture.cpp" target="_blank" rel="noopener">The texturing example code</a> by Jakob Progsch</li></ul>]]></content>
    
    <summary type="html">
    
      现代OpenGL贴图
    
    </summary>
    
      <category term="modern-opengl-tutorials" scheme="http://huangwei.pro/categories/modern-opengl-tutorials/"/>
    
    
      <category term="opengl" scheme="http://huangwei.pro/tags/opengl/"/>
    
      <category term="tutorials" scheme="http://huangwei.pro/tags/tutorials/"/>
    
  </entry>
  
  <entry>
    <title>游戏中的随机概率</title>
    <link href="http://huangwei.pro/2015-07/game-random/"/>
    <id>http://huangwei.pro/2015-07/game-random/</id>
    <published>2015-07-25T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.561Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间公司开发的游戏上线测试，许多玩家在抽卡时抱怨脸黑，很难抽到所需要的卡牌，而又有一部分玩家反应运气好能连着抽到紫卡，检查了下随机相关逻辑代码，并没有找出问题所在，玩家运气好与坏只是觉得真有可能是概率原因。</p><p>测试开服了几天之后，需要开放某个限时抽卡活动，在内部测试时，我们发现玩家反应的问题在限时抽卡中格外明显，尤其是其中最主要的一张稀有卡牌，猜测因为限时抽卡库配置的种类较少，然后就拿该活动来检查了下我们游戏随机机制问题。</p><a id="more"></a><h2 id="5-概率？20次出现一次？"><a href="#5-概率？20次出现一次？" class="headerlink" title="5%概率？20次出现一次？"></a>5%概率？20次出现一次？</h2><p>大部分游戏策划使用权值来配置随机概率，因为权值有个好处就是可以在增加随机物品时，可以不对之前的配置进行更改，比如：白卡 30，蓝卡 10，紫卡 10，转为概率即是：白卡 60%，蓝卡 20%，紫卡 20%。</p><p>而上述限时抽卡的例子中，我们的权值配置是5和95，模拟50000次随机（使用系统随机函数，如C的rand函数，Python的random库）得到如下结果：</p><p align="center"><br>    <img src="/static/img/rnd1.png" width="80%" alt="按权值随机50000次"><br></p><p>上图绘制的是权值为5的卡牌的随机状态，红色的图是分布图，X轴是出现的次数，Y轴是相同卡牌再次出现的间隔，简单得说就是，第x次卡牌出现时离上次该卡牌出现间隔了y次随机。绿色的图是分布概率图，X轴是间隔数，Y轴是概率。按策划的想法，<strong>5%概率</strong>应该等同于<strong>20次出现一次</strong>，那上图很明显并不满足<strong>20次出现一次</strong>出现规则，实际间隔从近到远呈下坡形状分布，就是说相邻的概率最大，间隔最大超过160，这与玩家所吐槽的抽卡体验是一致的。但50000次随机总共出现了2508次，从统计的意义上来说又是符合<strong>5%概率</strong>的。所以这个问题，究其原因就是所谓的概率是统计意义上的还是分布意义上的问题。</p><h2 id="最原始的实现"><a href="#最原始的实现" class="headerlink" title="最原始的实现"></a>最原始的实现</h2><p>我用列表里取元素的方式来模拟<strong>20次出现一次</strong>，为了方便比较异同，直接随机的方式我也贴上相关代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool = [<span class="number">0</span>]*<span class="number">5</span> + [<span class="number">1</span>]*<span class="number">95</span></span><br><span class="line">result = [random.choice(a) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N)]</span><br></pre></td></tr></table></figure><p>上面是直接随机的方式，只保证<strong>5%概率</strong>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool = []</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> pool:</span><br><span class="line">pool = [<span class="number">0</span>]*<span class="number">1</span> + [<span class="number">1</span>]*<span class="number">19</span></span><br><span class="line">random.shuffle(pool)</span><br><span class="line">result.append(pool[<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">del</span> pool[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>上面是打乱列表，然后依次取元素的方式，保证<strong>20次出现一次</strong>，而<strong>5%概率</strong>则是隐含在内的，生成效果如下图。</p><p align="center"><br>    <img src="/static/img/rnd2.png" width="80%" alt="使用第二种实现的随机分布"><br></p><p>该图明显跟第一个实现的图不一样，上图表明了间隔基本上是落在[0, 40]的区间内，并且均匀分布在20那条蓝色对称线附近。这个才是最终想要的随机的效果。红色的线是正态分布曲线，是不是很相似？后面我会讲到。</p><p>眼尖的会发现在第一个实现中我用的pool是<code>[0]*5 + [1]*95</code>，而第二个实现中我用的是<code>[0]*1 + [1]*19</code>。</p><p>这里<strong>20次出现一次</strong>并不等同于<strong>100次出现五次</strong>，也是从分布的意义上来说的，<strong>100次出现五次</strong>是存在5次连续出现的可能。</p><p>针对策划的配置，我们需要进行预处理，怎么处理？GCD啊~，5和95的最大公约数是5，所以在第二个实现的代码中我直接使用了1和19。</p><p>但这里有个问题，一般策划配置的随机库中肯定有多个物品。权值如果配置的比较随意的话，很可能就导致GCD为1，这样想要实现<strong>XX次出现一次</strong>就不可行了。比如刚才的权值配置5和95，再加一个权值为11的话，就只能实现<strong>111次出现5次</strong>。</p><p>所以这两种依赖列表的随机方式并不适用，一是需要维护的列表内存会比较大，二是对策划配置方式有过多约束。</p><h2 id="更通用更优美的实现"><a href="#更通用更优美的实现" class="headerlink" title="更通用更优美的实现"></a>更通用更优美的实现</h2><p><strong>20次出现一次</strong>是以20为标准周期，当然不能每次都是间隔20出现，这样就太假了，根本没有随机感受可言，为了模拟随机并可以控制一定的出现频率，我选择正态分布来进行伪随机分布生成，原因是分布会更自然一些。</p><p align="center"><br>    <img src="/static/img/rnd3_Normal_distribution.png" width="60%" alt="正态分布"><br></p><p>关于正态分布这里就不详细描述了，只需关心分布的两个参数即可，位置参数为$\mu$、尺度参数为$\sigma$。根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%。</p><p align="center"><br>    <img src="/static/img/rnd4_normal_sigma.png" width="60%" alt="根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%"><br></p><p>用上面的例子来定下参数，$\mu=20, \sigma=20/3$，这样每次按正态分布随机，就能得到一个理想的随机分布和概率区间。</p><p>C语言标准函数库中只有rand，如何生成符合正态分布的随机数可以参见<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83" target="_blank" rel="noopener">WiKi上的介绍</a>。这里我直接使用Python中random库中的normalvariate函数，当然gauss函数也是一样的，<a href="https://docs.python.org/2/library/random.html" target="_blank" rel="noopener">官方文档</a>上说gauss函数会快些，<a href="http://stackoverflow.com/questions/27749133/what-is-the-difference-between-random-normalvariate-and-random-gauss-in-pyth" target="_blank" rel="noopener">StackOverFlow</a>上说gauss是非线程安全函数，所以会快。我自己简单测试了下，在单线程情况下，gauss是会快些，但只是快了一点点而已。</p><p>首先，我直接生成权值为5的卡牌的间隔，检验下正态分布的随机效果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NN = int(N*<span class="number">0.05</span>)</span><br><span class="line">mu, sigma = <span class="number">20</span>, <span class="number">20</span>/<span class="number">3.</span></span><br><span class="line">delta = [int(random.normalvariate(mu, sigma)) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(NN)]</span><br></pre></td></tr></table></figure><p align="center"><br>    <img src="/static/img/rnd3.png" width="80%" alt="模拟正态分布的伪随机"><br></p><p>这图是不是比第二个实现的图更好看一些，分布也更平滑一些呢。OK，接下来就是替换旧的随机算法了。</p><h2 id="细节和优化"><a href="#细节和优化" class="headerlink" title="细节和优化"></a>细节和优化</h2><p>刚才说了随机库中会有很多物品，都需要按照各自的权值随机，并各自出现频率符合正态分布。下面我们来说说细节。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wtp = [<span class="number">1.</span>*x/sum(wt) <span class="keyword">for</span> x <span class="keyword">in</span> wt]</span><br><span class="line">result = []</span><br><span class="line">p = [random.normalvariate(<span class="number">1.</span>/x, <span class="number">1.</span>/x/<span class="number">3.</span>) <span class="keyword">for</span> x <span class="keyword">in</span> wtp]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">minp = <span class="number">1.e9</span></span><br><span class="line">minj = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j, pp <span class="keyword">in</span> enumerate(p):</span><br><span class="line"><span class="keyword">if</span> pp &lt; minp:</span><br><span class="line">minp = pp</span><br><span class="line">minj = j</span><br><span class="line">result.append(minj)</span><br><span class="line"><span class="keyword">for</span> j, pp <span class="keyword">in</span> enumerate(p):</span><br><span class="line">p[j] -= minp</span><br><span class="line">p[minj] = random.normalvariate(<span class="number">1.</span>/wtp[minj], <span class="number">1.</span>/wtp[minj]/<span class="number">3.</span>)</span><br></pre></td></tr></table></figure><p>这里我使用了统一的随机种子，随机测试了500万次后，所得的结果与多个随机种子差别不大。</p><p>简单解释下代码：初始化对所有物品按权值进行正态分布随机，每次取位置最小值的物品（也就是最先出现的），然后其它物品均减去该值，被取出的物品再单独进行一次正态分布随机，再次循环判断位置最小值。</p><p>这里，每次都需要对所有物品进行求最小值和减法，都是需要遍历的运算，我们可以有如下优化。</p><p>例如：(1,3,4) -&gt; 取1减1, (0,2,3) -&gt; 随机1, (1,2,3)，其实我们只是为了保持各物品之间位置的相对顺序即可，将对其它物品的减法变成对自己的加法，操作量级立马从$O(N)$缩为$O(1)$ 。</p><p>如上面的例子：(1,3,4) -&gt; 取1, (0,3,4) -&gt; 随机1加1, (2,3,4)，这样的操作不会改变物品序列的正确性。</p><p>熟悉最小堆的朋友，将查找最小值优化到$O(1)$应该也没啥问题吧。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wtp = [<span class="number">1.</span>*x/sum(wt) <span class="keyword">for</span> x <span class="keyword">in</span> wt]</span><br><span class="line">result = []</span><br><span class="line">p = [(random[i].normalvariate(<span class="number">1.</span>/x, <span class="number">1.</span>/x/<span class="number">3.</span>), i) <span class="keyword">for</span> x <span class="keyword">in</span> wtp]</span><br><span class="line">heapq.heapify(p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">minp, minj = heapq.heappop(p)</span><br><span class="line">result.append(minj)</span><br><span class="line">heapq.heappush(p, (random[minj].normalvariate(<span class="number">1.</span>/wtp[minj], <span class="number">1.</span>/wtp[minj]/<span class="number">3.</span>)+minp, minj))</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>问题分析和算法实现就到这了，替换进我的游戏里看看什么效果，我已经迫不及待了。</p><p>物品测试权值序列[10, 30, 50, 110, 150, 200, 250, 500]，随机测试500万次。</p><p align="center"><br>    <img src="/static/img/rnd_rand.png" width="80%" alt="第一个随机实现"><br>    <br>第一个随机实现<br></p><p>第一个实现是只符合统计要求，不符合分布要求。</p><p align="center"><br>    <img src="/static/img/rnd_weight.png" width="80%" alt="第二个随机实现"><br>    <br>第二个随机实现<br></p><p>第二个实现中对权值序列进行了GCD，可以看到只有绿色是符合分布要求的，而蓝色和青色退化成第一种实现。</p><p align="center"><br>    <img src="/static/img/rnd_normal.png" width="80%" alt="基于正态分布的随机实现"><br>    <br>基于正态分布的随机实现<br></p><p>完美！</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>当然，实现<strong>20次出现一次</strong>这样的分布伪随机还有其它方法，比如保存一个计数器，每随机一次就加到计数器上，当计数器的值大于或等于1，即必然出现。但这种实现需要计数器，每个玩家每个随机库每个物品都需要这么一个计数器字段，空间上实在太大了。</p><p>关于随机种子，除非是全服竞争类资源，不然最好每个玩家有各自的随机种子，否则会造成体验上的误差，比如抽卡、关卡掉落等这些只针对玩家自身的系统随机。服从正态分布的全局随机序列，不同玩家任意取走序列中一段或者一些值，就可能导致对于每个玩家而言，各自取出的随机序列不再服从正态分布。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>我只能感叹Python的库太强大了，matplotlib绘制出来的图形也挺漂亮的，感兴趣的童鞋可以查阅<a href="http://myshare.dscloud.me/scipydoc/" target="_blank" rel="noopener">用Python做科學計算</a>。</p>]]></content>
    
    <summary type="html">
    
      游戏中的随机概率
    
    </summary>
    
      <category term="develop" scheme="http://huangwei.pro/categories/develop/"/>
    
      <category term="dev-log" scheme="http://huangwei.pro/categories/develop/dev-log/"/>
    
    
      <category term="game" scheme="http://huangwei.pro/tags/game/"/>
    
      <category term="random" scheme="http://huangwei.pro/tags/random/"/>
    
      <category term="distribution" scheme="http://huangwei.pro/tags/distribution/"/>
    
  </entry>
  
  <entry>
    <title>现代OpenGL教程 01 - 入门指南</title>
    <link href="http://huangwei.pro/2015-05/modern-opengl1/"/>
    <id>http://huangwei.pro/2015-05/modern-opengl1/</id>
    <published>2015-05-12T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.563Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>    <img src="/static/img/opengl-tutorials/modern-opengl-01.png" width="60%"><br></p><h2 id="译序"><a href="#译序" class="headerlink" title="译序"></a>译序</h2><p>早前学OpenGL的时候还是1.x版本，用的都是<code>glVertex</code>，<code>glNormal</code>等固定管线API。后来工作需要接触DirectX9，shader也只是可选项而已，跟固定管线一起混用着。现在工作内容是手机游戏，又转到OpenGL ES，发现OpenGL的世界已经完全不同了，OpenGL ES 2.0版本开始就不再支持固定管线，只支持可编程管线。</p><a id="more"></a><p align="center"><br>    <img src="/static/img/opengl-tutorials/pipe2.0.png" width="60%"><br></p><p>国内很多资料教程参差不齐，旧式接口满天飞。在<a href="http://www.zhihu.com/question/22005157" target="_blank" rel="noopener">知乎</a>看到这一系列教程，觉着挺好，就想着一边学顺便翻译下。毕竟手游市场的机遇和竞争压力都在同比猛涨，多了解OpenGL ES肯定没有坏处。浮躁功利的环境下更需要怀着一颗宁静致远的心去提高自身功底，长路漫漫，与君共勉。</p><p>欢迎大家，这是现代OpenGL教程系列的第一篇。所有代码都是开源的，你可以在GitHub上下载：<a href="https://github.com/tomdalling/opengl-series" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series</a></p><p>通过这篇教程，你将会学到如何在Windows下用Visual Studio 2013或Mac下用Xcode搭建OpenGL 3.2工程。该应用包含一个顶点着色器（vertex shader），一个片段着色器（fragment shader）和使用VAO和VBO来绘制的三角形。该工程使用<a href="http://glew.sourceforge.net/" target="_blank" rel="noopener">GLEW</a>来访问OpenGL API，用<a href="http://www.glfw.org/" target="_blank" rel="noopener">GLFW</a>来处理窗口创建和输入，还有使用<a href="http://glm.g-truc.net/" target="_blank" rel="noopener">GLM</a>进行矩阵/矢量相关的数学运算。</p><p>这听上去有点无聊，但搭建这样的工程确实挺麻烦的，尤其对于初学者。只要解决完这问题，我们就可以开始玩些有趣的东西了。</p><p>[TOC]</p><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>所有例子代码的zip打包可以从这里获取：<a href="https://github.com/tomdalling/opengl-series/archive/master.zip" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series/archive/master.zip</a>。</p><p>这一系列文章中所使用的代码都存放在：<a href="https://github.com/tomdalling/opengl-series" target="_blank" rel="noopener">https://github.com/tomdalling/opengl-series</a>。你可以在页面中下载zip，加入你会git的话，也可以复制该仓库。</p><p>本文代码你可以在<code><a href="https://github.com/tomdalling/opengl-series/tree/master/source/01_project_skeleton" target="_blank" rel="noopener">source/01_project_skeleton</a></code>目录里找到。使用OS X系统的，可以打开根目录里的<code>opengl-series.xcodeproj</code>，选择本文工程。使用Windows系统的，可以在Visual Studio 2013里打开<code>opengl-series.sln</code>，选择相应工程。</p><p>工程里已包含所有依赖，所以你不需要再安装或者配置额外的东西。如果有任何编译或运行上的问题，请联系我。</p><h2 id="关于兼容性的提醒"><a href="#关于兼容性的提醒" class="headerlink" title="关于兼容性的提醒"></a>关于兼容性的提醒</h2><p>本文使用OpenGL 3.2，但我会尝试保持如下兼容：</p><ul><li>向后兼容OpenGL 2.1</li><li>向前兼容OpenGL 3.X和4.X</li><li>兼容Android和iOS的OpenGL ES 2.0</li></ul><p>因为OpenGL和GLSL存在许多不同版本，本文代码不一定能做到100%上述兼容。我希望能兼容99%，并且不同版本之间只要轻微修改即可。</p><p>想要了解OpenGL和GLSL不同版本间的区别，这里很好得罗列了<a href="http://web.eecs.umich.edu/~sugih/courses/eecs487/common/notes/APITables.xml" target="_blank" rel="noopener">兼容列表</a>。</p><h2 id="Visual-Studio下安装"><a href="#Visual-Studio下安装" class="headerlink" title="Visual Studio下安装"></a>Visual Studio下安装</h2><p>代码在Windows 7 32位系统，<a href="http://www.visualstudio.com/en-us/downloads/download-visual-studio-vs#DownloadFamilies_2" target="_blank" rel="noopener">Visual Studio Express 2013</a>（免费）下创建和测试。你应该可以打开解决方案并成功编译所有工程。如果有问题请联系我，或者将补丁发我，我会更新工程。</p><h2 id="Xcode下安装"><a href="#Xcode下安装" class="headerlink" title="Xcode下安装"></a>Xcode下安装</h2><p>Xcode工程实在OSX 10.10系统，Xcode 6.1下创建并测试的。打开Xcode工程应该可以成功编译所有目标。加入你无法成功编译请联系我。</p><h2 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h2><p>Linux是基于<a href="http://www.reddit.com/user/SpartanJ" target="_blank" rel="noopener">SpartanJ</a>。我在Ubuntu 12.04下简单测试通过。</p><ul><li>安装GLM，GLFW和GLEW：<br>  <code>sudo aptitude install libglm-dev libglew-dev libglfw-dev</code></li><li>进入工程目录：<code>cd platforms/linux/01_project_skeleto</code></li><li>运行makefile：<code>make</code></li><li>运行可执行文件：<code>bin/01_project_skeleton-debug</code></li></ul><h2 id="GLEW-GLFW和GLM介绍"><a href="#GLEW-GLFW和GLM介绍" class="headerlink" title="GLEW, GLFW和GLM介绍"></a>GLEW, GLFW和GLM介绍</h2><p>现在你有了工程，就让我们开始介绍下工程所用到的开源库和为啥需要这些。</p><p><a href="http://glew.sourceforge.net/" target="_blank" rel="noopener">The OpenGL Extension Wrangler (GLEW)</a>是用来访问OpenGL 3.2 API函数的。不幸的是你不能简单的使用<code>#include &lt;GL/gl.h&gt;</code>来访问OpenGL接口，除非你想用旧版本的OpenGL。在现代OpenGL中，API函数是在运行时（run time）确定的，而非编译期（compile time）。GLEW可以在运行时加载OpenGL API。</p><p><a href="http://www.glfw.org/" target="_blank" rel="noopener">GLFW</a>允许我们跨平台创建窗口，接受鼠标键盘消息。OpenGL不处理这些窗口创建和输入，所以就需要我们自己动手。我选择GLFW是因为它很小，并且容易理解。</p><p><a href="http://glm.g-truc.net/" target="_blank" rel="noopener">OpenGL Mathematics (GLM)</a>是一个数学库，用来处理矢量和矩阵等几乎其它所有东西。旧版本OpenGL提供了类似<code>glRotate</code>, <code>glTranslate</code>和<code>glScale</code>等函数，在现代OpenGL中，这些函数已经不存在了，我们需要自己处理所有的数学运算。GLM能在后续教程里提供很多矢量和矩阵运算上帮助。</p><p>在这系列的所有教程中，我们还编写了一个小型库<code>tdogl</code>用来重用C++代码。这篇教程会包含<code>tdogl::Shader</code>和<code>tdogl::Program</code>用来加载，编译和链接shaders。</p><h2 id="什么是Shaders？"><a href="#什么是Shaders？" class="headerlink" title="什么是Shaders？"></a>什么是Shaders？</h2><p>Shaders在现代OpenGL中是个很重要的概念。应用程序离不开它，除非你理解了，否则这些代码也没有任何意义。</p><p><mark>Shaders是一段GLSL小程序，运行在<strong>GPU</strong>上而非CPU</mark>。它们使用<a href="http://en.wikipedia.org/wiki/GLSL" target="_blank" rel="noopener">OpenGL Shading Language (GLSL)</a>语言编写，看上去像C或C++，但却是另外一种不同的语言。使用shader就像你写个普通程序一样：写代码，编译，最后链接在一起才生成最终的程序。</p><p>Shaders并不是个很好的名字，因为它不仅仅只做着色。只要记得它们是个用不同的语言写的，运行在显卡上的小程序就行。</p><p>在旧版本的OpenGL中，shaders是可选的。在现代OpenGL中，为了能在屏幕上显示出物体，shaders是必须的。</p><p>为可能近距离了解shaders和图形渲染管线，我推荐Durian Software的相关文章<a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-1:-The-Graphics-Pipeline.html" target="_blank" rel="noopener">The Graphics Pipeline chapter</a>。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">主程序</th><th style="text-align:left">Shader程序</th></tr></thead><tbody><tr><td style="text-align:left">语言</td><td style="text-align:left">C++</td><td style="text-align:left">GLSL</td></tr><tr><td style="text-align:left">主函数</td><td style="text-align:left">int main(int, char**);</td><td style="text-align:left">void main();</td></tr><tr><td style="text-align:left">运行于</td><td style="text-align:left">CPU</td><td style="text-align:left">GPU</td></tr><tr><td style="text-align:left">需要编译？</td><td style="text-align:left">是</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">需要链接？</td><td style="text-align:left">是</td><td style="text-align:left">是</td></tr></tbody></table><p>那shaders实际上干了啥？这取决于是哪种shader。</p><h2 id="Vertex-Shaders"><a href="#Vertex-Shaders" class="headerlink" title="Vertex Shaders"></a>Vertex Shaders</h2><p><mark>Vertex shader主要用来将点（x，y，z坐标）变换成不同的点。</mark>顶点只是几何形状中的一个点，一个点叫vectex，多个点叫vertices（发音为<a href="http://static.sfdict.com/dictstatic/dictionary/audio/luna/V00/V0096700.mp3" target="_blank" rel="noopener">ver-tuh-seez</a>）。在本教程中，我们的三角形需要三个顶点（vertices）组成。</p><p>Vertex Shader的GLSL代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version 150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> vec3 vert;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    // does <span class="keyword">not</span> alter the vertices at all</span><br><span class="line">    gl_Position = vec4(vert, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行<code>#version 150</code>告诉OpenGL这个shader使用GLSL版本1.50.</p><p>第二行<code>in vec3 vert;</code>告诉shader需要那一个顶点作为输入，放入变量<code>vert</code>。</p><p>第三行定义函数<code>main</code>，这是shader运行入口。这看上去像C，但GLSL中<code>main</code>不需要带任何参数，并且不用返回void。</p><p>第四行<code>gl_Position = vec4(vert, 1);</code>将输入的顶点直接输出，变量<code>gl_Position</code>是OpenGL定义的全局变量，用来存储vertex shader的输出。所有vertex shaders都需要对<code>gl_Position</code>进行赋值。</p><p><code>gl_Position</code>是4D坐标（vec4），但<code>vert</code>是3D坐标（vec3），所以我们需要将<code>vert</code>转换为4D坐标<code>vec4(vert, 1)</code>。第二个的参数<code>1</code>是赋值给第四维坐标。我们会在后续教程中学到更多关于4D坐标的东西。但现在，我们只要知道第四维坐标是<code>1</code>即可，i可以忽略它就把它当做3D坐标来对待。</p><p>Vertex Shader在本文中没有做任何事，后续我们会修改它来处理动画，摄像机和其它东西。</p><h2 id="Fragment-Shaders"><a href="#Fragment-Shaders" class="headerlink" title="Fragment Shaders"></a>Fragment Shaders</h2><p><mark>Fragment shader的主要功能是计算每个需要绘制的像素点的颜色。</mark></p><p>一个”fragment”基本上就是一个像素，所以你可以认为片段着色器（fragment shader）就是像素着色器（pixel shader）。在本文中每个片段都是一像素，但这并不总是这样的。你可以更改某个OpenGL设置，以便得到比像素更小的片段，之后的文章我们会讲到这个。</p><p>本文所使用的fragment shader代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version 150</span></span><br><span class="line"></span><br><span class="line">out vec4 finalColor;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    //set every drawn pixel to white</span><br><span class="line">    finalColor = vec4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次，第一行<code>#version 150</code>告诉OpenGL这个shader使用的是GLSL 1.50。</p><p>第二行<code>finalColor = vec4(1.0, 1.0, 1.0, 1.0);</code>将输出变量设为白色。<code>vec4(1.0, 1.0, 1.0, 1.0)</code>是创建一个RGBA颜色，并且红绿蓝和alpha都设为最大值，即白色。</p><p>现在，就能用shader在OpenGL中绘制出了纯白色。在之后的文章中，我们还会加入不同颜色和贴图。贴图就是你3D模型上的图像。</p><h2 id="编译和链接Shaders"><a href="#编译和链接Shaders" class="headerlink" title="编译和链接Shaders"></a>编译和链接Shaders</h2><p>在C++中，你需要对你的<code>.cpp</code>文件进行编译，然后链接到一起组成最终的程序。OpenGL的shaders也是这么回事。</p><p>在这篇文章中用到了两个可复用的类，是用来处理shaders的编译和链接：<code>tdogl::Shader</code>和<code>tdogl::Program</code>。这两个类代码不多，并且有详细的注释，我建议你阅读源码并且去链接OpenGL是如何工作的。</p><h2 id="什么是VBO和VAO？"><a href="#什么是VBO和VAO？" class="headerlink" title="什么是VBO和VAO？"></a>什么是VBO和VAO？</h2><p>当shaders运行在GPU，其它代码运行在CPU时，你需要有种方式将数据从CPU传给GPU。在本文中，我们传送了一个三角的三个顶点数据，但在更大的工程中3D模型会有成千上万个顶点，颜色，贴图坐标和其它东西。</p><p>这就是我们为什么需要Vertex Buffer Objects (VBOs)和Vertex Array Objects (VAOs)。<mark>VBO和VAO用来将C++程序的数据传给shaders来渲染。</mark></p><p>在旧版本的OpenGL中，是通过<code>glVertex</code>，<code>glTexCoord</code>和<code>glNormal</code>函数把每帧数据发送给GPU的。在现代OpenGL中，所有数据必须通过VBO在渲染之前发送给显卡。当你需要渲染某些数据时，通过设置VAO来描述该获取哪些VBO数据推送给shader变量。</p><h2 id="Vertex-Buffer-Objects-VBOs"><a href="#Vertex-Buffer-Objects-VBOs" class="headerlink" title="Vertex Buffer Objects (VBOs)"></a>Vertex Buffer Objects (VBOs)</h2><p>第一步我们需要从内存里上传三角形的三个顶点到显存中。这就是VBO该干的事。<mark>VBO其实就是显存的“缓冲区（buffers）” - 一串包含各种二进制数据的字节区域。</mark>你能上传3D坐标，颜色，甚至是你喜欢的音乐和诗歌。VBO不关心这些数据是啥，因为它只是对内存进行复制。</p><h2 id="Vertex-Array-Objects-VAOs"><a href="#Vertex-Array-Objects-VAOs" class="headerlink" title="Vertex Array Objects (VAOs)"></a>Vertex Array Objects (VAOs)</h2><p>第二步我们要用VBO的数据在shaders中渲染三角形。请记住VBO只是一块数据，它不清楚这些数据的类型。而告诉OpenGL这缓冲区里是啥类型数据，这事就归VAO管。</p><p><mark>VAO对VBO和shader变量进行了连接。它描述了VBO所包含的数据类型，还有该传递数据给哪个shader变量。</mark>在OpenGL所有不准确的技术名词中，“Vertex Array Object”是最烂的一个，因为它根本没有解释VAO该干的事。</p><p>你回头看下本文的vertex shader（在文章的前面），你就能发现我们只有一个输入变量<code>vert</code>。在本文中，我们用VAO来说明“hi，OpenGL，这里的VBO有3D顶点，我想要你在vertex shader时，发三个顶点数据给vert变量。”</p><p>在后续的文章中，我们会用VAO来说“hi，OpenGL，这里的VBO有3D顶点，颜色，贴图坐标，我想要你在shader时，发顶点数据给vert变量，发颜色数据给vertColor变量，发贴图坐标给vertTexCoord变量。”</p><p><strong>给使用上个OpenGL版本的用户的提醒</strong></p><p>假如你在旧版本的OpenGL中使用了VBO但没有用到VAO，你可能会不认同VAO的描述。你会争论说“顶点属性”可以用<code>glVertexAttribPointer</code>将VBO和shaders连接起来，而不是用VAO。这取决于你是否认为顶点属性应该是VAO“内置（inside）”的（我是这么认为的），或者说它们是否是VAO外置的一个全局状态。3.2内核和我用的AIT驱动中，VAO不是可选项 - 没有VAO的封装<code>glEnableVertexAttribArray</code>, <code>glVertexAttribPointer</code>和<code>glDrawArrays</code>都会导致<code>GL_INVALID_OPERATION</code>错误。这就是为啥我认为顶点属性应该内置于VAO，而非全局状态的原因。<a href="http://www.opengl.org/registry/doc/glspec32.core.20091207.pdf" target="_blank" rel="noopener">3.2内核手册</a>也说VAO是必须的，但我只听说ATI驱动会抛错误。下面描述引用自<a href="http://www.opengl.org/registry/doc/glspec32.core.20091207.pdf" target="_blank" rel="noopener">OpenGL 3.2内核手册</a></p><blockquote><p>所有与顶点处理有关的数据定义都应该封装在VAO里。<br>一般VAO边界包含所有更改vertex array状态的命令，比如VertexAttribPointer和EnableVertexAttribArray；所有使用vertex array进行绘制的命令，比如DrawArrays和DrawElements；所有对vertex array状态进行查询的命令（见第6章）。</p></blockquote><p>不管怎样，我也知道为啥会有人认为顶点属性应该放在VAO外部。<code>glVertexAttribPointer</code>出现早于VAO，在这段时间里顶点属性一直被认为是全局状态。你应该能看得出VAO是一种改变全局状态的有效方法。我更倾向于认为是这样：假如你没有创建VAO，那OpenGL通过了一个默认的全局VAO。所以当你使用<code>glVertexAttribPointer</code>时，你仍然是在VAO内修改顶点属性，只不过现在从默认的VAO变成你自己创建的VAO。</p><p>这里有更多的讨论：<a href="http://www.opengl.org/discussion_boards/showthread.php/174577-Questions-on-VAOs" target="_blank" rel="noopener">http://www.opengl.org/discussion_boards/showthread.php/174577-Questions-on-VAOs</a></p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>终于！理论已经说完了，我们开始编码。OpenGL对于初学者而言不是特别友好，但如果你理解了之前所介绍的概念（shaders，VBO，VAO）那你就没啥问题。</p><p>打开<code>main.cpp</code>，我们从<code>main()</code>函数开始。</p><p>首先，我们初始化GLFW：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glfwSetErrorCallback(OnError);</span><br><span class="line"><span class="keyword">if</span>(!glfwInit())</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"glfwInit failed"</span>);</span><br></pre></td></tr></table></figure><p><code>glfwSetErrorCallback(OnError)</code>这一行告诉GLFW当错误发生时调用<code>OnError</code>函数。<code>OnError</code>函数会抛一个包含错误信息的异常，我们能从中发现哪里出错了。</p><p>然后我们用GLFW创建一个窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">2</span>);</span><br><span class="line">glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">gWindow = glfwCreateWindow((<span class="keyword">int</span>)SCREEN_SIZE.x, (<span class="keyword">int</span>)SCREEN_SIZE.y, <span class="string">"OpenGL Tutorial"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(!gWindow)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"glfwCreateWindow failed. Can your hardware handle OpenGL 3.2?"</span>);</span><br></pre></td></tr></table></figure><p>该窗口包含一个向前兼容的OpenGL 3.2内核上下文。假如<code>glfwCreateWindow</code>失败了，你应该降低OpenGL版本。</p><p>创建窗口最后一步，我们应该设置一个“当前”OpenGL上下文给刚创建的窗口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(gWindow);</span><br></pre></td></tr></table></figure><p>无论我们调用哪个OpenGL函数，都会影响到“当前上下文”。我们只会用到一个上下文，所以设置完后，就别管它了。理论上来说，我们可以有多个窗口，且每个窗口都可以有自己的上下文。</p><p>现在我们窗口有了OpenGL上下文变量，我们需要初始化GLEW以便访问OpenGL接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glewExperimental = GL_TRUE; <span class="comment">//stops glew crashing on OSX :-/</span></span><br><span class="line"><span class="keyword">if</span>(glewInit() != GLEW_OK)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"glewInit failed"</span>);</span><br></pre></td></tr></table></figure><p>这里的GLEW与OpenGL内核有点小问题，设置<code>glewExperimental</code>就可以修复，但希望再未来永远不要发生。</p><p>我们也可以用GLEW再次确认3.2版本是否存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!GLEW_VERSION_3_2)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"OpenGL 3.2 API is not available."</span>);</span><br></pre></td></tr></table></figure><p>在<code>LoadShaders</code>函数中，我们使用本教程提供的<code>tdogl::Shader</code>和<code>tdogl::Program</code>两个类编译和链接了vertex shader和fragment shader。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tdogl::Shader&gt; shaders;</span><br><span class="line">shaders.push_back(tdogl::Shader::shaderFromFile(ResourcePath(<span class="string">"vertex-shader.txt"</span>), GL_VERTEX_SHADER));</span><br><span class="line">shaders.push_back(tdogl::Shader::shaderFromFile(ResourcePath(<span class="string">"fragment-shader.txt"</span>), GL_FRAGMENT_SHADER));</span><br><span class="line">gProgram = <span class="keyword">new</span> tdogl::Program(shaders);</span><br></pre></td></tr></table></figure><p>在<code>LoadTriangle</code>函数中，我们创建了一个VAO和VBO。这是第一步，创建和绑定新的VAO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;gVAO);</span><br><span class="line">glBindVertexArray(gVAO);</span><br></pre></td></tr></table></figure><p>然后我们创建和绑定新的VBO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glGenBuffers(<span class="number">1</span>, &amp;gVBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, gVBO);</span><br></pre></td></tr></table></figure><p>接着，我们上传一些数据到VBO中。这些数据就是三个顶点，每个顶点包含三个<code>GLfloat</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertexData[] = &#123;</span><br><span class="line">    <span class="comment">//  X     Y     Z</span></span><br><span class="line">     <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.8f</span>,<span class="number">-0.8f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertexData), vertexData, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>现在缓冲区包含了三角形的三个顶点，是时候开始设置VAO了。首先，我们应该启用shader程序中的<code>vert</code>变量。这些变量能被开启或关闭，默认情况下是关闭的，所以我们需要开启它。<code>vert</code>变量是一个“属性变量（attribute variable）”，这也是为何OpenGL函数名称中有带“Attrib”。我们可以在后续的文章中看到更多类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnableVertexAttribArray(gProgram-&gt;attrib(<span class="string">"vert"</span>));</span><br></pre></td></tr></table></figure><p>VAO设置最复杂的部分就是下个函数：<code>glVertexAttribPointer</code>。让我们先调用该函数，等会解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(gProgram-&gt;attrib(<span class="string">"vert"</span>), <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>第一个参数，<code>gProgram-&gt;attrib(&quot;vert&quot;)</code>，这就是那个需要上传数据的shder变量。在这个例子中，我们需要发数据给<code>vert</code>shader变量。</p><p>第二个参数，<code>3</code>表明每个顶点需要三个数字。</p><p>第三个参数，<code>GL_FLOAT</code>说明三个数字是<code>GLfloat</code>类型。这非常重要，因为<code>GLdouble</code>类型的数据大小跟它是不同的。</p><p>第四个参数，<code>GL_FALSE</code>说明我们不需要对浮点数进行“归一化”，假如我们使用了归一化，那这个值会被限定为最小0，最大1。我们不需要对我们的顶点进行限制，所以这个参数为false。</p><p>第五个参数，<code>0</code>，该参数可以在顶点之间有间隔时使用，设置参数为0，表示数据之间没有间隔。</p><p>第六个参数，<code>NULL</code>，假如我们的数据不是从缓冲区头部开始的话，可以设置这个参数来指定。设置该参数为NULL，表示我们的数据从VBO的第一个字节开始。</p><p>现在VBO和VAO都设置完成，我们需要对它们进行解绑定，防止一不小心被哪里给更改了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>到此，shader，VBO和VAO都准备好了。我们可以开始在<code>Render</code>函数里绘制了。</p><p>首先，我们先清空下屏幕，让它变成纯黑色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glClearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// black</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>然后告诉OpenGL我们要开始使用VAO和shader了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(gProgram-&gt;object());</span><br><span class="line">glBindVertexArray(gVAO);</span><br></pre></td></tr></table></figure><p>最后，我们绘制出三角形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>调用<code>glDrawArrays</code>函数说明我们需要绘制三角形，从第0个顶点开始，有3个顶点被发送到shader。OpenGL会在当前VAO范围内确定该从哪里获取顶点。</p><p>顶点将会从VBO中取出并发送到vertex shader。然后三角形内的每个像素会发送给fragment shader。接着fragment shader将每个像素变成白色。欢呼！</p><p>现在绘制结束了，为了安全起见，我们需要将shader和VAO进行解绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">glUseProgram(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最后一件事，在我们看到三角形之前需要切换帧缓冲：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(gWindow);</span><br></pre></td></tr></table></figure><p>在帧缓冲被交换前，我们会绘制到一个不可见的离屏（off-screen）帧缓冲区。当我们调用<code>glfwSwapBuffers</code>时，离屏缓冲会变成屏幕缓冲，所以我们就能在窗口上看见内容了。</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>在后续文章中，我们会对三角形进行贴图。之后，你会学到一点矩阵变换知识，就可以使用vertex shader来实现3D立方体旋转。</p><p>在这之后，我们开始创建3D场景并提交多个物体。</p><h2 id="更多现代OpenGL资料"><a href="#更多现代OpenGL资料" class="headerlink" title="更多现代OpenGL资料"></a>更多现代OpenGL资料</h2><p>不幸的是，我不得不跳过很多内容，防止本教程的篇幅过长。后面还有很多好的现代OpenGL资料能满足你的求知欲：</p><ul><li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html" target="_blank" rel="noopener">An intro to modern OpenGL</a> by Joe Groff of Durian Software</li><li><a href="http://www.arcsynthesis.org/gltut/" target="_blank" rel="noopener">Learning Modern 3D Graphics Programming</a> by Jason L. McKesson</li><li><a href="https://github.com/progschj/OpenGL-Examples" target="_blank" rel="noopener">A collection of simple single file OpenGL examples</a> by Jakob Progsch</li><li><a href="http://ogldev.atspace.co.uk/" target="_blank" rel="noopener">OpenGL Step by Step</a> by Etay Meiri</li><li><a href="http://db-in.com/blog/2011/01/all-about-opengl-es-2-x-part-13/" target="_blank" rel="noopener">All about OpenGL ES 2.x</a> by Diney Bomfim</li><li><a href="http://en.wikibooks.org/wiki/OpenGL_Programming" target="_blank" rel="noopener">The OpenGL Progamming book on Wikibooks</a></li><li><a href="http://www.opengl.org/wiki/Tutorials" target="_blank" rel="noopener">Tutorials on the OpenGL wiki</a></li><li><a href="http://www.swiftless.com/tutorials/opengl4/1-opengl-window.html" target="_blank" rel="noopener">OpenGL 4 tutorials</a> by Donald Urquhart (Swiftless)</li><li><a href="http://open.gl/" target="_blank" rel="noopener">open.gl</a> by Alexander Overvoorde</li><li><a href="http://openglbook.com/" target="_blank" rel="noopener">OpenGLBook.com</a> by Eddy Luten</li><li><a href="http://www.opengl.org/sdk/docs/" target="_blank" rel="noopener">The official OpenGL SDK documentation</a></li><li><a href="http://web.eecs.umich.edu/~sugih/courses/eecs487/common/notes/APITables.xml" target="_blank" rel="noopener">Compatibility tables for OpenGL, OpenGL ES, GLSL, and GLSL ES</a> by Sugih Jamin</li></ul>]]></content>
    
    <summary type="html">
    
      现代OpenGL在Xcode，Visual C++和Linux下的入门指南
    
    </summary>
    
      <category term="modern-opengl-tutorials" scheme="http://huangwei.pro/categories/modern-opengl-tutorials/"/>
    
    
      <category term="opengl" scheme="http://huangwei.pro/tags/opengl/"/>
    
      <category term="tutorials" scheme="http://huangwei.pro/tags/tutorials/"/>
    
  </entry>
  
  <entry>
    <title>游戏中的 2D 可见性</title>
    <link href="http://huangwei.pro/2015-04/game-visiablity/"/>
    <id>http://huangwei.pro/2015-04/game-visiablity/</id>
    <published>2015-04-27T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.562Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/static/2dvisibilitydemo/jquery-ui-1.8.19.custom.css"><p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/86268/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>2D的俯视图经常用于从给定点计算可视区域。例如，你可能想把某些东西隐藏在玩家看不见的地方，亦或你想知道点燃火炬后能看见什么地方。</p><p>拖动圆点转一圈，看看玩家都能看到些什么：</p><div id="maze"><img class="placeholder" src="/static/2dvisibilitydemo/static-lightmap.png"></div><p>这个算法也能计算出给定光源所照亮的区域。对每条光线，我们可以构建出被照亮区域的光线图。如果我们给上面的迷宫放上24个灯呢？见光线图。</p><p>roguelike<span style="color: #888888;">（译注：类地下城RPG游戏统称）</span>社区已经收集了<a href="http://roguebasin.roguelikedevelopment.org/index.php/Category:FOV" target="_blank" rel="noopener">好几种算法</a>，尤其是网格类的。消减算法是从可见的一切区域开始，减去不可见区域；添加算法是从不可见区域开始，加上可见区域。我将描述一种可工作于线段的添加算法，不仅仅是固体分块或者网格。</p><a id="more"></a><h2 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h2><p>一个简单地方法是从中心点投射光线，这是得到一个近似解的合理的第一步：</p><div id="diagram-raycast-interval" class="right"></div><p>更聪明的是，让光线投射到所有墙体的开端和末端。这些光线所产生的三角形就是可见区域：</p><div id="diagram-raycast-endpoints" class="right"></div><p>就是这样！该算法如下：</p><ol><li>计算到墙体开始或结束的角度。</li><li>从中心点沿各个角度投出光线。</li><li>对这些光线所产生的三角形进行填充。</li></ol><h2 id="墙体跟踪"><a href="#墙体跟踪" class="headerlink" title="墙体跟踪"></a>墙体跟踪</h2><p>我们可以到此为止了，尤其是如果我们有一个快速光线投射算法，可使用空间哈希以避免与每一个墙体进行相交计算。然而，更有效的方法是将光线投射和墙体相交结合成一个算法。我将在这里描述了一种圆形扫描算法，对所有的击中点按角度进行排序; 它也可以扩展成圆形外扩算法，对所有的击中点按半径排序，但我还没有尝试过这种方法。</p><p>位于连续几个射线之间的区域，我们需要找到最近的墙。这面墙就被照亮了; 所有其他墙面应该被隐藏。我们的策略是360°扫描，处理所有的墙端点。当运行时，我们会持续跟踪与扫描线相交的墙壁。点击观看端点扫描：</p><div class="right"><div id="diagram-sweep-points"></div></div><p>下一步骤是将跟踪哪些墙壁会被扫描线穿过。只有最近的壁是可见的。你如何找出哪些墙壁是最近的？最简单的方法是计算从中心到墙的距离。然而，如果墙壁大小不同，这种方法不能很好地工作，所以演示中使用一个稍微复杂的方法，这里我就不解释了。</p><p>按PLAY可看到扫描中最近的墙面以白色绘制和其他墙面绘成黑色。</p><div class="right"><div id="diagram-sweep-segments"></div></div><p>每当最近的墙面终止，或者有新的墙面比其它的都近时，我们创建了一个三角形表示可见区域。这些三角形的并集就是所述中心点的可视区域。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var endpoints;      <span class="comment"># 端点列表，按角度排序</span></span><br><span class="line">var open = [];      <span class="comment"># 墙面列表，按距离排序</span></span><br><span class="line">loop over endpoints: <span class="comment">#遍历 endpoints</span></span><br><span class="line">    remember which wall <span class="keyword">is</span> nearest <span class="comment">#记住哪个墙面最近</span></span><br><span class="line">    add any walls that BEGIN at this endpoint to <span class="string">'walls'</span> <span class="comment"># 把所有以该端点开始的墙面添加到“墙面列表“中</span></span><br><span class="line">    remove any walls that END at this endpoint <span class="keyword">from</span> <span class="string">'walls'</span><span class="comment"># 把所有以该端点截止的墙面从“墙面列表“中删除</span></span><br><span class="line">    SORT the open list <span class="comment">#对open数组排序</span></span><br><span class="line"><span class="keyword">if</span> the nearest wall changed: <span class="comment">#假如最近的墙面改变:</span></span><br><span class="line">    fill the current triangle <span class="keyword">and</span> begin a new one<span class="comment">#填充当前三角形并且开始新的</span></span><br></pre></td></tr></table></figure><p>需要注意的是创建一个三角形涉及到之前与扫描线相交的墙面。其结果是，三角形的新边缘可能长于或短于扫描线，并且该三角形最远的边缘比之前的墙面短。</p><h2 id="试验场"><a href="#试验场" class="headerlink" title="试验场"></a>试验场</h2><p>这里有一块试验场，有很多可用的方块。可以拖拽方块到网格内。点击play/pause按钮可以查看算法运行，或者移动中心点查看哪些是可见的，就像玩家四处查看一样。</p><div class="right"><div id="diagram-playground"></div></div><br><div id="haxe:trace"></div><h2 id="组合输出"><a href="#组合输出" class="headerlink" title="组合输出"></a>组合输出</h2><p>我们可以使用集合运算以有趣的方式组合该算法的输出。这些也可被实现为用布尔运算分析输出，或者用位图操作渲染输出。</p><h3 id="玩家视野"><a href="#玩家视野" class="headerlink" title="玩家视野"></a>玩家视野</h3><p>限制玩家的视野最简单的操作是将输出与有限的视野求交集。例如，相交算法使用圆圈来限制可见半径。与渐变填充圈相交，可使光按距离改变明暗。与圆锥相交可打造出“手电筒”效果，可以让你把前面看得更远，但没有相应视野在你身后（见随后<a href="http://www.tuaw.com/2012/04/16/phil-hasseys-anathema-mines-renamed-dynamite-jack-gets-a-trail/" target="_blank" rel="noopener">Dynamite Jack</a>的一个例子）。假如用双眼代替单点，玩家的视野也更好看。我希望你可以合并所有眼睛的可视区域，但我还没有试过。</p><h3 id="地图物体"><a href="#地图物体" class="headerlink" title="地图物体"></a>地图物体</h3><p>可见性也可用于计算哪些区域被火炬点亮。在页面的顶部演示了首先对每个火炬所点亮的区域进行求并集，然后与玩家可以看见的区域相交。（请注意，此算法会产生硬阴影，你将不得不对输出进行后处理来获得软阴影。）</p><p>同样的计算可用于确定哪些地区可被安全摄像头可以看到，有哪些被盾牌保护着，或者是否足够靠近某些魔法设施，使它赋予你属性加成或是诅咒。</p><h3 id="AI行为"><a href="#AI行为" class="headerlink" title="AI行为"></a>AI行为</h3><p>可见性也可用于构建AI行为。例如，假设敌人的AI是想扔了一枚手榴弹击中玩家，也想站在玩家射击不到的地方。手榴弹需要足够近才能击中玩家，并且无法击中障碍物后面的。下图显示标注了AI单位的地图的可能计算：</p><div class="right"><div id="grenade"></div></div><p>手榴弹扔进紫色区域将成功击中一名玩家。黄色和紫色区域是危险区域; 玩家可以从那里攻击AI单位。AI需要站在一个安全的区域（深蓝色）并且投掷了一枚手榴弹到紫色区域，然后寻找掩体。如何计算掩体？在AI准备投掷手雷的地方再次运行可见性算法，让橱柜和桌子挡住视线。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我已经用<a href="http://www.redblobgames.com/articles/visibility/Visibility.hx" target="_blank" rel="noopener">HAXE 3</a>来实现这个算法，使用Apache v2开源协议（类似MIT和BSD，它可以在商业项目中使用）。HAXE代码可以编译成JavaScript，ActionScript，C ++，Java，C#或PHP。我把它编译成JavaScript来制作这个网页，并为我的其他项目编译成Flash。我编译成以下语言：</p><ul><li><a href="http://www.redblobgames.com/articles/visibility/as3-version.zip" target="_blank" rel="noopener">Actionscript</a> ; 可读，因为Actionscript和Haxe并非截然不同</li><li><a href="http://www.redblobgames.com/articles/visibility/output/_visibility.js" target="_blank" rel="noopener">Javascript</a>（用于此页面上的演示）; 大多是可读的。</li><li><a href="http://www.redblobgames.com/articles/visibility/java-version.zip" target="_blank" rel="noopener">Java</a> ; 轻度可读，但不是很好。</li><li><a href="http://www.redblobgames.com/articles/visibility/csharp-version.zip" target="_blank" rel="noopener">C#</a> ; 轻度可读，但不是很好。Roy Triesscheijn有一个更好的版本<a href="http://roy-t.nl/index.php/2014/02/27/2d-lighting-and-shadows-preview/" target="_blank" rel="noopener">在这里</a>。</li></ul><p>Wade Tritschler建议<a href="http://www.redblobgames.com/articles/visibility/#comment-850486470" target="_blank" rel="noopener">手工移植</a>，所产生的代码要比使用Haxe输出的代码更干净。我同意这个观点。如果你手写代码还可以更好得了解该算法。尽管该算法主要在CPU中进行，可以使用GPU为位图进行三角形渲染和合并位图输出。（布尔AND操作可变成位图乘法;布尔OR操作可变成位图添加和钳位。）在我的项目中该性能已经足够，所以我还没有构建GPU版本。如果你的游戏有CPU限制，可以考虑使用消减算法（而不是这里显示的添加算法），渲染四边形的每条线段的影子。它会增加GPU渲染负载，但它并不需要在CPU上排序。如果填充率是一个问题，考虑渲染一个比游戏画面分辨率低的光度图，然后扩大它。</p><h2 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h2><p><a href="http://ncase.me/sight-and-light/" target="_blank" rel="noopener">视觉和光线</a>覆盖了可见性的问题; 在我的<a href="http://simblob.blogspot.com/2012/07/2d-visibility.html" target="_blank" rel="noopener">博客文章</a>有更多的链接。<a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank" rel="noopener">地平线问题</a>类似2D可见性问题，但它在直角坐标系中，而不是极坐标。另外还有<a href="http://en.wikipedia.org/wiki/Art_gallery_problem" target="_blank" rel="noopener">美术馆问题</a>，关于放置多少个警卫就可以看到地图的每一个区域。我正Trello上创建了一份列表，<a href="https://trello.com/c/m0yhEv6U/37-visibility-version-2" target="_blank" rel="noopener">未来可能更新这个页面</a>。</p><script type="text/javascript" src="/static/2dvisibilitydemo/jquery-1.7.2.min.js"></script><script type="text/javascript" src="/static/2dvisibilitydemo/jquery-ui-1.8.19.custom.min.js"></script><script type="text/javascript" src="/static/2dvisibilitydemo/visibility.js"></script><script type="text/javascript" src="/static/2dvisibilitydemo/demo-canvas.js"></script>]]></content>
    
    <summary type="html">
    
      游戏中的 2D 可见性
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="game" scheme="http://huangwei.pro/tags/game/"/>
    
      <category term="2d" scheme="http://huangwei.pro/tags/2d/"/>
    
      <category term="visibility" scheme="http://huangwei.pro/tags/visibility/"/>
    
  </entry>
  
  <entry>
    <title>高效率生活</title>
    <link href="http://huangwei.pro/2015-03/effective-living/"/>
    <id>http://huangwei.pro/2015-03/effective-living/</id>
    <published>2015-03-06T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间就是金钱"><a href="#时间就是金钱" class="headerlink" title="时间就是金钱"></a>时间就是金钱</h2><p>我们从小被教育到时间就是金钱，但一到生活清闲或者工作很忙的时候，就忘记了时间的存在，等回过神来时，时间已经一溜烟的过去了。</p><p>当我每每躺在床上临睡时，就觉得这一天过的十分罪恶，好像啥事都没干，久而久之就有了睡前强迫综合征。想必很多程序员朋友也深有同感吧。</p><p>为了减轻心理压力，提高工作效率，优化生活质量，我开始寻找各种工具，包括开发的、生活的等等。</p><a id="more"></a><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p>互联网时代谁也离不开网络，尤其在天朝的GFW下，可获取的有用信息少之又少，其次就是卡、慢。</p><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>VPN的好处是能翻墙，用google，下载软件包，能上国外的好多网站，个人娱乐也可以看看YouTube之类的。</p><p>网上很多朋友是自己买VPS，然后搭建VPN的。</p><p>我转了圈，发现好的VPS贵，只是为了撘个VPN感觉不值。</p><p>买了个听说便宜口碑好的，发现根本不是那么会事，老是断线连不上，发邮件给客服回答说，机房里好多大陆的网站，都有些敏感信息，所以该机房被墙掉了，导致无辜用户被波及。</p><p>想想还是买现成的VPN服务吧，我使用过<code>MxVPN</code>和<code>Nydus</code>。<code>MxVPN</code>的免费账号每月送的流量还挺多，不过他的线路有各种限制，比如只能开网页的，只能玩网游的等等，外加Win客户端做的很土气，看着不爽。<code>Nydus</code>的客户端做的好看多了，而且Win和Mac下都有，用着还是可以，偶尔网络断线重新选择下线路即可，不过Mac端连接成功率很低。Mac下<code>鱼摆摆</code>的口碑不错，不过只限定在Mac环境下，所以我没尝试过。</p><h3 id="红杏"><a href="#红杏" class="headerlink" title="红杏"></a>红杏</h3><p>我用VPN最大的需求还是上网浏览查资料，所以<code>红杏</code>是我现在一直使用的Chrome插件，在<code>goagent</code>不稳定的时候，<code>红杏</code>省了我不少时间。安装配置简单，价格便宜，所以极力推荐，有需要的朋友可以点这个<a href="http://honx.in/i/VMNeMOz5NC4lQMrc" target="_blank" rel="noopener">链接</a>，你我都可以得到优惠。</p><h2 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h2><p>作为游戏开发者，经常需要关注一些业界消息和技术大牛的blog。</p><p>我用<code>NewsBlur</code>订阅相应RSS，主要关注：</p><ul><li>(开源计算机图形学论坛)[<a href="http://www.opengpu.org/forum.php" target="_blank" rel="noopener">http://www.opengpu.org/forum.php</a>]</li><li>(游戏大观)[<a href="http://www.gamelook.com.cn/" target="_blank" rel="noopener">http://www.gamelook.com.cn/</a>]</li><li>(触乐)[<a href="http://www.chuapp.com/" target="_blank" rel="noopener">http://www.chuapp.com/</a>]</li><li>(虎嗅)[<a href="http://www.huxiu.com/" target="_blank" rel="noopener">http://www.huxiu.com/</a>]</li><li>(游戏邦)[<a href="http://gamerboom.com/" target="_blank" rel="noopener">http://gamerboom.com/</a>]</li><li>(游戏葡萄)[<a href="http://youxiputao.com/" target="_blank" rel="noopener">http://youxiputao.com/</a>]</li><li>(游资网)[<a href="http://www.gameres.com/" target="_blank" rel="noopener">http://www.gameres.com/</a>]</li><li>(开源中国)[<a href="http://www.oschina.net/" target="_blank" rel="noopener">http://www.oschina.net/</a>]</li><li>(码农周刊)[<a href="http://weekly.manong.io/" target="_blank" rel="noopener">http://weekly.manong.io/</a>]</li><li>(StartupNews)[<a href="http://news.dbanotes.net/" target="_blank" rel="noopener">http://news.dbanotes.net/</a>]</li><li>(V2EX)[<a href="http://www.v2ex.com/" target="_blank" rel="noopener">http://www.v2ex.com/</a>]</li><li>(GameDev)[<a href="http://www.gamedev.net/page/index.html" target="_blank" rel="noopener">http://www.gamedev.net/page/index.html</a>]</li><li>各大牛人Blog，如云风等</li></ul><p><code>NewsBlur</code>可以结合iOS上的App<code>Reeder</code>，体验也是不错，不过由于我的订阅有点多，所以iPhone上看起来有点累。</p><p>每天接触的信息会很多，我用<code>EverNote</code>的剪藏插件来收集一些觉得有价值的资料。如果是纯文本资料，我喜欢用<code>readability</code>的插件抓取，阅读效果类似<code>悦读</code>，但<code>readability</code>有send to kindle功能，能在<code>kindle</code>上获得更好的阅读体验，当然<code>kindle</code>也有iOS端。其实，我很比较喜欢多平台的应用，好处是随时随地都可以进行阅读。</p><p>至于新闻类的，我觉得<code>网易阅读</code>是做的最好的，没有之一。新闻时效性较强，内容也很丰富。不过为了节约时间，新闻类的要少看，基本过下标题即可。</p><p><code>知乎</code>也是个好地方，问题和回答相对专业，我关注了一些有名的开发者，每天推送过来的内容，都能让我觉得很新奇很好玩。</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>关于纸质书籍，我已经越来越少在这上面花时间了。但不代表我不买书了（要剁手啊！），尤其是手册等工具类书基本只会偶尔翻翻，教材类书籍也没空长时间阅读（这是个不好的现象，虽然很多问题都能google到，但是按着教程走下来，领会的能更深入）。</p><p>包括买<code>kindle</code>前，一直大量收集pdf文档，买了之后又开始大量收集电子书，光下不看，我得检讨下~</p><p>导致每次看到书架上一堆书，kindle和电脑上一大堆电子书，我已经觉得这辈子都看不完了，有心无力。</p><p>最近几年我阅读的社科、文化、经管类书籍多于技术类的，看这些书籍就像发现新大陆一样，会有渴求感，看完后回头再看技术类书籍反倒觉得思路更开阔了。写程序应该也是门艺术，艺术的事物与其它很多东西是相通的，所以多读读非技术类书没有坏处。</p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>很多时候，可移动设备携带也不是那么方便，现如今云存储应用这么普及，个人文档和一些数据文件可以存在云上。我自己现在用的是<code>百度云</code>，以前用<code>dropbox</code>不过可惜被墙，而且总不能在所有终端上都安装个VPN吧，所以我选择了国内的服务。用下来其实也还可以，国内有些资源只要在云上进行保存即可，都不用下到本地再上传，节省很多下载时间和流量。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="GTD"><a href="#GTD" class="headerlink" title="GTD"></a>GTD</h3><p>现在市面上的GTD产品挺多的，我使用的Omni序列，比如TODO列表<code>Focus</code>，大纲<code>Outliner</code>，进度计划<code>Plan</code>都是不错的辅助工具，支持Mac和iOS双端，iClound数据同步。</p><p>另外<code>番茄工作法</code>也是个选择，虽然我觉得25分钟一个番茄，中间被打断就得重新来过这样的一个方式不适合项目开发中的个人事务管理，但它贵在规则简单好执行，用来记录自己的专注度还是可以的。</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>虽然iOS和电脑上都有思维导图软件，画出来的图也相当漂亮。但我只是在写doc或者做ppt时才会拿来当画图工具用，真正方便的还是一本本子和一支笔，随时随地记录点滴想法，想画啥就画成啥，根本不用担心图形库里有没你想要的形状。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>进入程序员的专用工具领域。</p><p>我不会Vim和Emacs，虽然曾经很想学，但是每次要记录各种按键和命令，我就觉得还不如之前的方式好用，可能它们属于学习曲线前期陡峭后期平滑的那种。但不管这些，反正我现在用的<code>Sublime Text</code>，已经觉得足够顺手，插件丰富，可定制化也比较好。</p><p>C++在Win下肯定还是<code>Visual Studio</code>，Mac下也是毫无疑问的<code>XCode</code>。不过<code>Visual Studio</code>下大家都会安装<code>Visual Assitante X</code>吧？</p><p>Python和Lua之类的脚本，我用的都是<code>Sublime Text</code>，配置下脚本也能当个IDE来使。</p>]]></content>
    
    <summary type="html">
    
      创业过程中的点点滴滴记录
    
    </summary>
    
      <category term="startup" scheme="http://huangwei.pro/categories/startup/"/>
    
    
      <category term="effective" scheme="http://huangwei.pro/tags/effective/"/>
    
      <category term="summary" scheme="http://huangwei.pro/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>创业小结（一）</title>
    <link href="http://huangwei.pro/2015-01/startup1/"/>
    <id>http://huangwei.pro/2015-01/startup1/</id>
    <published>2015-01-24T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作2年"><a href="#工作2年" class="headerlink" title="工作2年"></a>工作2年</h2><p>2011年的5月份，在<code>杭州研究院</code>的<code>闪电邮</code>项目已上线并作为稳定版本告一段落，组里人员开始被调配到其它项目，考虑到PC客户端产品的市场日渐式微，而且在<code>网易</code>这种游戏公司PC客户端只会作为战略产品或者辅助工具，很难有直接营收（那会闪电邮已经有百万用户量，网易邮箱用户的粘性非常高，超越Foxmail成为用户首选客户端）。在这种情况下，我开始考虑转型。那时方向有二，朋友推荐可以去<code>支付宝</code>数据基础平台部门，部门老大建议去公司新成立的<code>雷电</code>游戏工作室。考虑到留在网易，同事朋友和离家近，游戏项目是公司主业等因素下开始了又一段的苦逼之旅。</p><p>回头看那时的选择，我并不后悔选择游戏行业，只是叹息当时只关注了方向，而没仔细考察工作室的人员组成和产品经理资历。而当年在支付宝的那朋友升到了系统架构师，前年去了鹅厂。</p><a id="more"></a><h2 id="工作5年"><a href="#工作5年" class="headerlink" title="工作5年"></a>工作5年</h2><p>2014年5月20日我选择了离职。原本预计一年的产品开发期被各种因素拖成了三年，而且在这三年中越来越明白一件事，产品是团队协作的产物，产品的高度取决于程序策划美术中能力最弱的部门，而产品经理的眼界和思维决定了产品能走多远，还有在大公司中，产品经理包括各部门负责人的人脉和资源也是非常重要的，所以跟对人和产品，选对团队比自己埋头苦干更有效。</p><p>这些因素在大公司中是需要时间、人脉和精力去慢慢获得的，作为偏内向重技术的码农而言，在这方面我知道自己积累不够，而另外一方面，三年的游戏开发技术和些许主程的管理经验的积累。在火热的手游产业召唤下，不仅仅是心痒痒，而是期许能带出一个战斗力过硬的团队，实现成功游戏产品的理想。机遇不会等你做好万全准备，毅然放弃N+1的补偿，与工作室里的几个小伙伴一起出来创业。</p><h2 id="创业组建阶段"><a href="#创业组建阶段" class="headerlink" title="创业组建阶段"></a>创业组建阶段</h2><p>前面提到了团队人员架构很重要，创业当然不能盲目，我们团队初期人员都来自同一个工作室，程序策划美术商务都不缺，缺的就是资金到位。原本一直跟我们有联系的<code>元鼎</code>，迟迟没有跟我们签正式合同，而这时我们已经出来快一个月了，刚好朋友帮忙联系上了<code>真格</code>，真格那边比较爽快，签完合同直接先预支了一半天使资金，使得我们能顺利的租好办公场地，购置设备和团队组建。</p><p>2014年6月20日，7个人的团队正式开始上班，2程序2策划2美术1商务，我们三个创始人（Luo，我，Lu）按1：2：4的比例控股，10%作为期权池，其他人均持5%。针对我们团队成员年龄和工龄相仿，采用了全员持股，群体决策，创始人拍板，设制作人（主策），主程，主美的行政架构。</p><p>期间也为拉队友出来和股份的事跟队友促膝长谈多次，有朋友考虑家庭因素不愿出来，也有朋友不满意占比的，好说歹说各种做工作，总算都确定下来了，但也给后面留下些许不稳定因素，但总归人员齐备，开始一起干活了。</p><h2 id="创业第一个月"><a href="#创业第一个月" class="headerlink" title="创业第一个月"></a>创业第一个月</h2><p>技术选型以后重新开篇再写，这里只是记录下研发过程中进度和流程所踩过的坑。一开始我们就以<code>刀塔传奇</code>为范本，希望深化战斗体验，还原魔兽世界中打副本的感觉，初步定下2D横轴、位置不可操作的AI战斗形式，再以此为基础开发活动，刷塔，PVP，Boss战等玩法。</p><p>那首先战斗Demo我们很快就开发出来了，但动作和场景都是拿网上资源代替的，感官效果不好。过了一个月，基础的战斗逻辑完成，策划开始使用替代资源编辑关卡。美术依然不停地再找外包测试，定风格这类事上。</p><h2 id="创业第二月"><a href="#创业第二月" class="headerlink" title="创业第二月"></a>创业第二月</h2><p>服务器框架，网络通讯，协议加密，数据库操作等等都好了，也完成了初期卡片系统，跟客户端开始协议交互。第一阶段的战斗逻辑的需求也完成了，开始细节优化。动画制作规范也摸索的差不多了，基本抛弃<code>DragonBones</code>继续使用<code>CocosStudio</code>，包括UI也使用CocosStudio搭建。但这时很扯淡的是外包回来的速度慢，美术效果还是不够理想，场景美术虽然换了一批，但是看上去有点惨不忍睹。此时已有出现问题的苗头，美术风格迟迟定不下来，外部制作的动作不尽如人意。我们只能不停的跟外包反馈，和主美讨论风格和方向。系统方面我也催促尽快出文档，但Lu的想法是战斗体验最重要，系统缓缓。那会程序急行军只是开发出了原型，我想着缓缓倒也没事，客户端可以先继续做逻辑，服务器底层功能先完善下。</p><h2 id="创业第三月"><a href="#创业第三月" class="headerlink" title="创业第三月"></a>创业第三月</h2><p>开通了QQ云服务器，买了App Store开发者账号，还购置了一台Mac mini。从我角度发现，手游程序开发，尤其2D卡牌项目，远比我之前想的简单多了，可能之前我还陷在三年的端游痛苦开发经历上。现在程序不仅进度遥遥领先，开发效率简直分分钟完成策划需求，有赖于客户端Cocos2dx+Lua，服务器Python+Redis开发，程序员的人生立马充满欢颜笑语，不会因为C++中内存泄露，崩溃等问题而抓狂。在我欣喜程序效率之余，危险的阴影已经开始笼罩。</p><p>Lu和Luo基本将精力都放在了外包把控上，但因为不是美术专业，很多东西反馈回来，然后交给主美看，找出问题后，再写反馈意见给外包，这一来二去非常费时间。而且这时出现了一个重大问题，也是我们迄今为止最大的经济损失，前期我们没有好好考察主美的实际能力，包括他画的场景和给外包的美术意见，我们都觉得不好，但又没法以专业角度去说啥，导致外包做了一大批动作，后来基本都给废弃了，这里所浪费的外包费足以让我们小团队撑上4个月的。</p><p>其次美术外包的事，还影响到关卡体验上的优化被拖后，不管啥问题，最后也都以没有资源或体现不出效果为由而搁置。系统文档严重落后，我跟Lu反应多次，但说来说去又会把问题指向外包上，导致在外包这事解决前，凡事都无解。后来这事越拖越久，我们都意识到不能再因为这事而拖延游戏开发进度，碰巧Lu的一个策划朋友刚辞职，然后就被Lu拉过来帮忙写系统文档。</p><p>这个月是从创业以来，程序最闲的一个月，但也是很郁闷的一个月，团队中充斥着一种懒散和无奈的氛围，对于一个创业的小团队而言，这肯定不是件好事。期间我们也开始使用<code>redmine</code>来记录周报，每周开会总结上周进度和预估下周工作，但收效不明显，因为原本加入这个制度是为了控制开发进度，而进度瓶颈又在美术，美术工作质量又很难衡量尤其是我们非专业的来看，所以执行一段时间后不了了之。</p>]]></content>
    
    <summary type="html">
    
      创业过程中的点点滴滴记录
    
    </summary>
    
      <category term="startup" scheme="http://huangwei.pro/categories/startup/"/>
    
    
      <category term="summary" scheme="http://huangwei.pro/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>超酷算法：字谜树</title>
    <link href="http://huangwei.pro/2015-01/anagram-Trees/"/>
    <id>http://huangwei.pro/2015-01/anagram-Trees/</id>
    <published>2015-01-16T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.559Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/83217/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>我毫不犹豫的把这个算法称为“超酷”，虽然我自己发明了它，但我还是觉得它相当的酷，而且它很适合我算法系列的主题，所以无论如何要把它写下来。</p><a id="more"></a><p>当涉及到寻找单词字谜时，用的比较频繁的方法是字谜字典，简单得说，对单词的字母进行排序，以提供一个单词与所有字谜共同点的唯一索引。另外一种方法是为单词里的每个字母生成字母频率直方图。（这两种方法实际上或多或少相同。）这些方法查找确切的单字字谜字符串非常高效 - 如果使用哈希表，复杂度为O(1)。</p><p>然而，如果问题是查找字谜的子集（包含一个字符串里字母的一个子集的单词），仍然是相当低效的，通常需要在O(n)时间内暴力搜索整个字典，或者查找每个有序字符串的子串，复杂度与输入字符串的字母长度有关，为O(2^l)。查找字谜子集显然更有趣，因为它能查找多字字谜，可以应用在拼字游戏上。</p><p>不管怎样，我们先生成能唯一表示一组字母的直方图，再努力观察，我们可以生成一个树结构来更有效得查找字谜子集。为了构建这样的树，我们按照如下几个简单的步骤：</p><p>假设我们有如下信息：</p><ul><li>一个词典或单词字典来填充树</li><li>词典中单词的字母表</li><li>一个正在构建的树</li><li>当前节点</li></ul><p>词典里的每个单词：</p><p> 1.为该单词生成字母频率直方图。</p><p> 2.设当前节点为树的根节点。</p><p> 3.每个字母表里的字符：</p><p> 获取当前字符在当前单词里的频率，记为f</p><p> 设置当前节点为当前节点的第f个子节点，如果它不存在的话就创建</p><p> 4.将当前单词添加到当前（叶）节点上的单词列表</p><p>以下是这个简单过程的结果，它是一棵固定高度的树，27个节点深，所有单词都在叶节点中，并且树的每个层级对应字母表里的字符。下面是个简略的例子（译注：原博客图片遗失，从WIKI上找了张替图）：</p><p><a href="http://fanyi.jobbole.com/wp-content/uploads/sites/9/2014/10/Image_of_an_anatree1.png" target="_blank" rel="noopener"><img src="http://fanyi.jobbole.com/wp-content/uploads/sites/9/2014/10/Image_of_an_anatree1-300x197.png" alt="Image_of_an_anatree1"></a></p><p>一旦树创建好后，我们可以如下方式查找输入字符串的字谜集合：</p><p>假设我们有如下信息：</p><p>由上述流程所构建的树</p><p> 上面使用过的字母表</p><p> 一个边界集合，初始化为空</p><p>1.初始化时边界集合只包含树的根节点</p><p> 2.生成输入字符串的字母频率直方图</p><p> 3.对字母表中的每个字符：</p><p> 1.获取当前字符在输入字符串里的频率，记为f</p><p> 2.对边界集合里的每个节点，添加标号为0到f的子节点到新的边界集合中</p><p> 4.当前边界集合中包含的叶节点，包含所有输入字符串的字谜子集</p><p>至少对我来说，对该算法进行运行期分析比较困难。直观的看，它在实践中比任何一种蛮力算法要快很多，但我无法量化为大O表示法。作为一个上限，它不可能比O(n)的效率低，最坏也比蛮力算法少一个常数因子。作为下限值，边界集合中只有一个节点，那查找时间就与字母表长度成正比，为O(1)。平均情况下，依赖输入字符串所选择的字典的子集有多大。以输出的大小来量化的话，需要O(m)的操作。如果有人知道如何确定运行时更准确的范围的话，请在评论中让我知晓。</p><p>这个算法有个缺点就是，需要大量的内存开销。我用python来实现，并导入/usr/share/dict/words，在本机上这大约是2MB的大小，但需要占用内存300MB。使用Pickle模块序列化到磁盘，输出文件的大小超过30MB，使用gzip压缩后下降到大约7MB。我怀疑内存大的部分原因是python字典的最小尺寸。我将使用列表来实现，如果我能够做到更高效，届时我会更新这篇文章。</p><p>这里是上述所生成树的数据，可能你会感兴趣：</p><p> 总单词数：234,936</p><p> 叶节点：215,366</p><p> 内部节点：1,874,748</p><p>由此我们可以看出，内部节点的平均基数是非常低的，不会大于1。下面数据有助于澄清：</p><table><tbody><tr><th>Tier</th><th>Number of nodes</th></tr><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>7</td></tr><tr><td>2</td><td>25</td></tr><tr><td>3</td><td>85</td></tr><tr><td>4</td><td>203</td></tr><tr><td>5</td><td>707</td></tr><tr><td>6</td><td>1145</td></tr><tr><td>7</td><td>1886</td></tr><tr><td>8</td><td>3479</td></tr><tr><td>9</td><td>8156</td></tr><tr><td>10</td><td>8853</td></tr><tr><td>11</td><td>10835</td></tr><tr><td>12</td><td>19632</td></tr><tr><td>13</td><td>28470</td></tr><tr><td>14</td><td>47635</td></tr><tr><td>15</td><td>73424</td></tr><tr><td>16</td><td>92618</td></tr><tr><td>17</td><td>94770</td></tr><tr><td>18</td><td>125018</td></tr><tr><td>19</td><td>156406</td></tr><tr><td>20</td><td>182305</td></tr><tr><td>21</td><td>195484</td></tr><tr><td>22</td><td>200031</td></tr><tr><td>23</td><td>203923</td></tr><tr><td>24</td><td>205649</td></tr><tr><td>25</td><td>214001</td></tr></tbody></table><p>靠近树的顶部节点的基数非常高，但树很快变平，最后四层树只占总结点的一半。这暗示了一个可能的空间优化：删除树的最后几层，将它们的叶子节点连在一起。当进行查找时，检查所选的节点，保证它们是输入字符串的字谜集合。</p><ul><li>我可能只是重新发现了计算机科学领域30年前就被提及的论文。但惊喜的是，通过搜索尚未找到谁正在使用该算法，或者有其它方法比蛮力算法更有效。</li></ul><p>修订：最初的实现<a href="http://blog.notdot.net/uploads/anagramfinder.pys" target="_blank" rel="noopener">代码</a>在这。</p><p>修订：使用列表来重新实现我的python代码，几乎节约了一半内存。有机会我会贴出pickled后的树和源码。</p><p>修订：更多更新<a href="http://blog.notdot.net/archives/39-Update-on-Anagram-Trees.html" target="_blank" rel="noopener">在这</a>。</p><p>（译注：字谜问题可简化为字符串编码和索引问题，如Tea编码为A1E1T1，编码哈希后，同编码单词有Ate，Eat等。文章写于2007年，文中算法不是最优解，只是提供了一种使用多路查找树的思路，类似数据结构有Trie，DAG，Suffix Tree等等。）</p>]]></content>
    
    <summary type="html">
    
      超酷算法：字谜树
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="tree" scheme="http://huangwei.pro/tags/tree/"/>
    
      <category term="trie" scheme="http://huangwei.pro/tags/trie/"/>
    
      <category term="string" scheme="http://huangwei.pro/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>超酷算法：分组密码与安全排列</title>
    <link href="http://huangwei.pro/2015-01/secure-permutations-with-block-ciphers/"/>
    <id>http://huangwei.pro/2015-01/secure-permutations-with-block-ciphers/</id>
    <published>2015-01-15T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.567Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/83218/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>作为开始，我假设你知道什么是排列，简单说就是按特定的顺序对序列进行洗牌。比如，值域1-10的排列为{5,2,1,6,8,4,3,9,7,10} 。一个安全的排列是攻击者即使有该排列的任意子集，都无法确定其它任何一个元素的顺序。这里有个简单的例子是使用一个安全加密的伪随机数生成器，用一个密钥作为种子，并用它来打乱你的序列。</p><p>如果你想生成一个非常非常大的排列，一个如此大的预计算和存储是不是不太现实？此外，你是否希望它是个安全序列？这里有个非常巧妙的方法，我们可以使用分组密码，使我们能够产生超过数值范围内的任何一个安全排列，而不必对它们进行预计算。</p><p>分组密码，没人不熟悉，它是密码学中一种常见的基础元素。它是由多块一定长度的密文组成，密文一般为64或128位的加密串。相同的密钥和相同的明文，它只可能生成相同的密文。超过一个块大小的信息使用一系列操作模式中的某一种方式加密，继而可以针对比单个块大许多的消息进行安全的加密和解密。使用分组密码加密，选择操作模式是至关重要的。为了能生成一个安全排列，无论如何，我们只打算每次加密单个块，所以我们不必担心操作模式。</p><p>如果你知道分组密码是如何运作的，你肯定能获得一个安全的排列。将给定长度的任意块（考虑下块的数量非常大的情况）用唯一的方式转换为另外一个块，且能将它再次转换回来。如果我们逐步加密更大的数字（1,2,3等等），我们保证能得到看上去随机的序列，只要不重复输入。这点很容易证明：假如它是重复的，那你会有两个输入数字被解码为同一个输出数字，这样就不可能有独一无二的解码。分组密码所持有的这些特性也正是对我们有用的特性。</p><p>你说，一切都挺好，但如果我想要一个不是2的幂次值域内的排列该如何？这里有个聪明的小技巧，就是取一个块长度略大于你想要的长度的分组密码，使用上面描述的方法，逐步加密序列中的更大数值，以产生排列中的元素。当加密后的值超出你想要的排列值域之外，只需再次加密。重复这样的方式直到你给到你想要的值域内的数值。同样，我们能保证分组密码的唯一性，并且我们也能保证（穷举方式）最终获得了一个理想值域内的数值。</p><p>很显然，在追寻这条路之前我们需要考虑一些因素。你要选择一个分组密码，是不是比你想生成的序列的值域要大，最好是2的幂次。密码值域和排列值域的比率确定了你运行的平均时间， 因此，如果密码是你排列的值域的四倍时，你就对每个值平均需要四次加密。这可能产生问题，因为大多数密码是64，128或者更多位。为了这个目的，我们找到适应性比较强的TEA加密算法，它很容易构造32,64,128或者更长位的变体，并且位操作在main主循环那很容易调整，也可产生4的幂次长度的密码，而无需将密码缩短至容易被暴力破解的长度。</p><p>另外值得一提的是，虽然这个技术的目的是生成非常大的安全排列，但对那些并不注重安全的排列同样有用 - 你的密钥可作为生成排列的随机种子。在许多情况下这种方法同样有帮助，基本上它是个映射函数可以用来索引排列的数值，这样你可以计算出该排列的任意子集的值。</p><p>最后，请记住，由于可能的排列数呈阶乘级增长，你的密钥空间肯定大大小于排列的数量。这个对于大多数应用可能并不重要，因为如此庞大的排列不可能一个个枚举过去。但是，如果你的密钥过短，它就有可能被攻击者利用枚举密钥的方式来找出可能生成的排列。</p><p>更新：Yossi Oren在评论里留了分优秀的论文连接。它涵盖了我的描述（当然更全面）。</p>]]></content>
    
    <summary type="html">
    
      超酷算法：分组密码与安全排列
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="security" scheme="http://huangwei.pro/tags/security/"/>
    
      <category term="encryption" scheme="http://huangwei.pro/tags/encryption/"/>
    
      <category term="permutation" scheme="http://huangwei.pro/tags/permutation/"/>
    
  </entry>
  
  <entry>
    <title>超酷算法：BK树</title>
    <link href="http://huangwei.pro/2014-10/bktree/"/>
    <id>http://huangwei.pro/2014-10/bktree/</id>
    <published>2014-10-21T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.560Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/78811/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>这是『超酷算法』系列的第一篇文章。基本上，任何一种算法我觉得都很酷，尤其是那些不那么明显简单的算法。</p><p>BK树或者称为Burkhard-Keller树，是一种基于树的数据结构，被设计于快速查找近似字符串匹配，比方说拼写检查器，或模糊查找，当搜索”aeek”时能返回”seek”和”peek”。为何BK-Trees这么酷，因为除了穷举搜索，没有其他显而易见的解决方法，并且它能以简单和优雅的方法大幅度提升搜索速度。</p><p>BK树在1973年由Burkhard和Keller第一次提出，论文在这《<a href="http://portal.acm.org/citation.cfm?id=362003.362025" target="_blank" rel="noopener">Some approaches to best match file searching</a>》。这是网上唯一的ACM存档，需要订阅。更细节的内容，可以阅读这篇论文《<a href="http://citeseer.ist.psu.edu/1593.html" target="_blank" rel="noopener">Fast Approximate String Matching in a Dictionary</a>》。</p><p>在定义BK树之前，我们需要预先定义一些操作。为了索引和搜索字典，我们需要一种比较字符串的方法。编辑距离（ <a href="http://en.wikipedia.org/wiki/Levenshtein_Distance" target="_blank" rel="noopener">Levenshtein Distance</a>）是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数。其它字符串函数也同样可接受（比如将调换作为原子操作），只要能满足以下一些条件。</p><p>现在我们观察下编辑距离：构造一个度量空间（<a href="http://en.wikipedia.org/wiki/Metric_space" target="_blank" rel="noopener">Metric Space</a>），该空间内任何关系满足以下三条基本条件：</p><ul><li><p>d(x,y) = 0 &lt;-&gt; x = y (假如x与y的距离为0，则x=y)</p></li><li><p>d(x,y) = d(y,x) (x到y的距离等同于y到x的距离)</p></li><li><p>d(x,y) + d(y,z) &gt;= d(x,z)</p></li></ul><p>上述条件中的最后一条被叫做三角不等式（<a href="http://en.wikipedia.org/wiki/Triangle_inequality" target="_blank" rel="noopener">Triangle Inequality</a>）。三角不等式表明x到z的路径不可能长于另一个中间点的任何路径（从x到y再到z）。看下三角形，你不可能从一点到另外一点的两侧再画出一条比它更短的边来。</p><p>编辑距离符合基于以上三条所构造的度量空间。请注意，有其它更为普遍的空间，比如欧几里得空间（Euclidian Space），编辑距离不是欧几里得的。既然我们了解了编辑距离（或者其它类似的字符串距离函数）所表达的度量的空间，再来看下Burkhard和Keller所观察到的关键结论。</p><p>假设现在我们有两个参数，query表示我们搜索的字符串，n表示字符串最大距离，我们可以拿任意字符串test来跟query进行比较。调用距离函数得到距离d，因为我们知道三角不等式是成立的，所以所有结果与test的距离最大为d+n，最小为d-n。</p><p>由此，BK树的构造就相当简单：每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注n表示编辑距离恰好为n。比如，我们有棵树父节点是”book”和两个子节点”rook”和”nooks”，”book”到”rook”的边标号1，”book”到”nooks”的边上标号2。</p><p>从字典里构造好树后，取任意单词作为树的根节点。无论何时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。比如，插入”boon”到刚才上述例子的树中，我们先检查根节点，查找d(“book”, “boon”) = 1的边，然后检查标号为1的边的子节点，得到单词”rook”。我们再计算距离d(“rook”, “boon”)=2，则将新单词插在”rook”之后，边标号为2。</p><p>在树中做查询，计算单词与根节点的编辑距离d，然后递归查找每个子节点标号为d-n到d+n（包含）的边。假如被检查的节点与搜索单词的距离d小于n，则返回该节点并继续查询。</p><p>BK树是多路查找树，并且是不规则的（但通常是平衡的）。试验表明，1个查询的搜索距离不会超过树的5-8%，并且2个错误查询的搜索距离不会超过树的17-25%，这可比检查每个节点改进了一大步啊！需要注意的是，如果要进行精确查找，也可以非常有效地通过简单地将n设置为0进行。</p><p>回顾这篇文章，写的有点长哈，似乎比我预期中的要复杂。希望你在阅读之后，也能感受到BK树的优雅和简单。</p>]]></content>
    
    <summary type="html">
    
      超酷算法：BK树
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="tree" scheme="http://huangwei.pro/tags/tree/"/>
    
      <category term="trie" scheme="http://huangwei.pro/tags/trie/"/>
    
      <category term="string" scheme="http://huangwei.pro/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>「毁灭战士3」源码就是“保持简洁”的证明</title>
    <link href="http://huangwei.pro/2014-07/doom-clean-code/"/>
    <id>http://huangwei.pro/2014-07/doom-clean-code/</id>
    <published>2014-07-29T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.561Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/83438/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>假如你在网上搜最好的C++源代码。「毁灭战士3 | Doom 3」的源代码肯定会被提到好多次，这篇就来证明此事。</p><p><span style="color: #888888;">我花了一些时间通读了 DOOM3 的源代码。这可能是我见过的最干净最漂亮的代码了。</span></p><p>DOOM3是<a href="http://en.wikipedia.org/wiki/Id_Software" title="Id Software" target="_blank" rel="noopener">id Software</a>公司开发 <a href="http://en.wikipedia.org/wiki/Activision" title="Activision" target="_blank" rel="noopener">Activision</a>发行的视频游戏。该游戏为id Software赢得了商业上的成功，已售出350万多份拷贝。</p><p><img src="http://ww2.sinaimg.cn/large/7cc829d3jw1e4zbnxsznrj20ai06lq3u.jpg" alt=""></p><p>在2011年11月23日，id Software维持开源传统，发布了他们上一个引擎的<a href="https://github.com/dhewm/dhewm3" target="_blank" rel="noopener">源代码</a>。这份源代码已经被很多开发者审查，这里就有个fabien反馈的例子（<a href="http://fabiensanglard.net/doom3_bfg/" target="_blank" rel="noopener">链接</a>）：</p><p><span style="color: #888888;">DOOM3 BFG是用C++写的，一种庞大的语言，它既能写出优秀的代码，但也让人憎恶到眼睛流血。幸运的是，id Software退而求其次，使用C++子集，接近于“带类的C”，如以下几条约束：</span></p><ul><li><span style="line-height: 13px; color: #888888;">没有异常</span></li><li><span style="color: #888888;">没有引用（使用指针）</span></li><li><span style="color: #888888;">少用模板</span></li><li><span style="color: #888888;">使用常量（Const everywhere）</span></li><li><span style="color: #888888;">类</span></li><li><span style="color: #888888;">多态</span></li><li><span style="color: #888888;">继承</span></li></ul><p>很多C++专家不建议使用“带类的C”这样的方法。然而，DOOM3从2000开发至2004，没有使用任何现代C++机制。</p><p>让我们使用 CppDepend 来看看源代码，探索它得特别之处。</p><p>DOOM3有少量的几个工程组成，这儿有它的工程列表和一些类型统计。</p><p><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eohinbexqej20ed05odh4.jpg" alt=""></p><p>这里还有他们之间的依赖关系图：</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohinasrfqj20lo094dhk.jpg" alt=""></p><p>DOOM3定义了很多全局函数。但是，大部分内容实现是在类中。</p><p>数据模型使用结构体定义。为了在源代码中对结构体的使用有个更具体的理解，在下图中将它们以蓝色分块显示出来。</p><p>在图表中，代码被表示为树形图，树形图表示法能使用嵌套的矩形来表示树状结构。而树结构用来表示代码分层结构。</p><ul><li><span style="line-height: 13px;">工程包含命名空间。</span></li><li>命名空间包含类型。</li><li>类型包含函数和域（field）。</li></ul><p><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eohinagm9ij20le0an44r.jpg" alt=""></p><p>我们可以观察到它定义了许多的结构体，比如DoomDLL 40%的类型都是结构体。它们被有条理地用来定义数据模型。该实践已经被很多工程所接受，这种方法有个最大的缺点是多线程应用，结构体的public变量并非不可改变的。</p><p>为何支持不可变对象，有个重要原因：能显著地简化并发编程。考虑下，写个合格的多线程程序是个艰巨的任务吗？因为很难同步线程访问资源（对象或者其他OS资源）。为什么同步这些操作很困难呢？因为很难保证在资源竞争状态下多线程对多个对象进行正确的读写操作。假如没有写操作呢？换句话说，线程只访问这些对象，而不做任何变动？这样就不再需要同步操作了！</p><p>让我搜索下只有一个基类的类：</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohin9ofg3j20bt08jabe.jpg" alt=""></p><p>几乎40%的结构体和类都只有一个基类。通常，OOP（面对对象编程）使用继承的好处之一是多态，下面蓝色标明了源代码中的虚函数：</p><p><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1eohin97by0j20n00aqn45.jpg" alt=""></p><p>超过30%的函数是虚函数。少数是纯虚函数，下面是所有虚基类列表：</p><p><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eohin8oam0j20av0drdhs.jpg" alt=""></p><p>只有52个类被定义为虚基类，其中35个类只是纯接口，也就是这些接口都是纯虚函数。</p><p><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eohin8eycvj20aw0dp0vc.jpg" alt=""></p><p>我们来搜搜使用了RTTI的函数</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohin7xurlj20c20ds77l.jpg" alt=""></p><p>只有非常少的函数使用了RTTI。</p><p>为保证只使用OOP最基础的概念，不使用高级设计模式，不过度使用接口和虚基类，限制了RTTI的使用并且数据都定义为结构体。</p><p>至此这份代码跟很多C++开发者所批评的“带类的C”没太大区别。</p><p>其开发者的一些有趣的选择，帮助我们理解它的奥秘：</p><p><strong>1-为有用的服务提供公用的基础类。</strong></p><p>许多类是从idClass继承下来的：</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohin7juvpj20ax0ds0v6.jpg" alt=""></p><p>idClass提供如下服务：</p><ol><li><span style="line-height: 13px;">创建实例化</span></li><li>类型管理</li><li>事件管理</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eohin6s68bj20aw0cgjts.jpg" alt=""></p><p><strong>2-方便的字符串操作</strong></p><p>一般来说，字符串是一个项目里用的最多的对象，许多地方需要使用它，并且需要函数来对其进行操作。</p><p>DOOM3定义了idstr类，几乎包含了所有用的字符串操作函数，无需再自己定义函数来接受其它框架所提供的字符串类。</p><p><strong>3-源代码与GUI框架（MFC）高度解耦</strong></p><p>很多工程用了MFC后，它的代码就会与MFC类型高度耦合，并且在代码的任何一处都能发现MFC类型。</p><p>在DOOM3里，代码和MFC是高度解耦的，只有GUI类才会直接依赖它。下面的CQLinq查询可以展示这点：</p><p><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1eohin65onej20bk0ds0w6.jpg" alt=""></p><p>这样的选择对生产力有很大的影响。事实上，只有GUI开发者才会关心MFC框架，其它开发者不应该被强制在MFC上浪费时间。</p><p><strong>4-提供了非常好的公共函数库（idlib）</strong></p><p>几乎在所有项目中都会用到公共工具类，就如以下查询的结果：</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohin5r7msj20bi0dsaco.jpg" alt=""></p><p>正如我们所看到经常使用的就是公共工具类。假如C++开发者不使用一个良好的公共工具框架，那就会为解决技术层面问题花费大部分的开发时间。</p><p>idlib提供了很多有用的类用于字符串处理，容器和内存。有效促进了开发者的工作，并且能让他们更多的关注在游戏逻辑上。</p><p><strong>5-实现非常易于理解</strong></p><p>DOOM3实现了非常难的编译器，对于C++开发者而言，开发语法解析器和编译器不是件轻松的事。尽管如此，DOOM3的实现非常容易被理解并且编写得十分干净。</p><p>这儿有这些编译器的类的依赖图：</p><p><img src="http://ww1.sinaimg.cn/mw690/6941baebgw1eohin5clqhj20k609udh7.jpg" alt=""></p><p>这儿还有编译器源代码的代码片段：</p><p><img src="http://ww2.sinaimg.cn/mw690/6941baebgw1eohin4wztzj20is0e9juu.jpg" alt=""></p><p>我们也看过许多语法解析器和编译器的代码，但这是第一次我们发现编译器是如此得容易理解，和整个DOOM3源代码一样。这太神奇了。当我们探究DOOM3源代码时，我们忍不住会喊：喔，这太漂亮了！</p><p><strong>总结</strong></p><p>即使DOOM3选择了很基础的设计，但它的设计者所做的决定都是为了开发者能更多的关注游戏逻辑本身，并且为所有技术层面的东西提供便利。这提高了多大的生产力啊。</p><p>无论何时使用“带类的C”，你应该明白你自己在干什么。你必须像DOOM3的开发专家一样。但不推荐初学者忽视现代C++建议而冒险。</p>]]></content>
    
    <summary type="html">
    
      「毁灭战士3」源码就是“保持简洁”的证明
    
    </summary>
    
      <category term="develop" scheme="http://huangwei.pro/categories/develop/"/>
    
    
      <category term="doom" scheme="http://huangwei.pro/tags/doom/"/>
    
      <category term="zen" scheme="http://huangwei.pro/tags/zen/"/>
    
  </entry>
  
  <entry>
    <title>30 行 Python 代码搞定 X 算法</title>
    <link href="http://huangwei.pro/2014-07/python-30-x/"/>
    <id>http://huangwei.pro/2014-07/python-30-x/</id>
    <published>2014-07-21T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.567Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在没有搭建这个Blog之前帮jobbole翻译的，现在只是复制回来自己做个存档，<a href="http://blog.jobbole.com/74000/" target="_blank" rel="noopener">jobbole链接在这</a>。</p><hr><p>假如你对数独解法感兴趣，你可能听说过<a href="http://zh.wikipedia.org/wiki/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">精确覆盖问题</a>。给定全集 <code>X</code>和 <code>X</code>的子集的集合 <code>Y</code>，存在一个 Y 的子集 Y<em>，使得 Y</em> 构成 X 的一种分割。</p><p>这儿有个Python写的例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">Y = &#123;</span><br><span class="line">    <span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">    <span class="string">'B'</span>: [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">'C'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">    <span class="string">'D'</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    <span class="string">'E'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="number">2</span>, <span class="number">7</span>]&#125;</span><br></pre></td></tr></table></figure><p>这个例子的唯一解是<code>[&#39;B&#39;, &#39;D&#39;, &#39;F&#39;]。</code></p><p>精确覆盖问题是NP完备<span style="color: #888888;">（译注：指没有任何一个够快的方法可以在合理的时间内，意即多项式时间 找到答案）</span>。<a href="http://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X" target="_blank" rel="noopener">X算法</a>是由大牛高德纳发明并实现。他提出了一种高效的实现技术叫<a href="http://en.wikipedia.org/wiki/Dancing_Links" target="_blank" rel="noopener">舞蹈链</a>，使用双向链表来表示该问题的矩阵。</p><p>然而，舞蹈链实现起来可能相当繁琐，并且不易写地正确。接下来就是展示Python奇迹的时刻了！有天我决定用Python来编写<code>X</code>算法，并且我想出了一个有趣的舞蹈链变种。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>主要的思路是使用字典来代替双向链表来表示矩阵。我们已经有了 <code>Y</code>。从它那我们能快速的访问每行的列元素。现在我们还需要生成行的反向表，换句话说就是能从列中快速访问行元素。为实现这个目的，我们把X转换为字典。在上述的例子中，它应该写为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;<span class="string">'A'</span>, <span class="string">'B'</span>&#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;<span class="string">'E'</span>, <span class="string">'F'</span>&#125;,</span><br><span class="line">    <span class="number">3</span>: &#123;<span class="string">'D'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">    <span class="number">4</span>: &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>&#125;,</span><br><span class="line">    <span class="number">5</span>: &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;,</span><br><span class="line">    <span class="number">6</span>: &#123;<span class="string">'D'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">    <span class="number">7</span>: &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>眼尖的读者能注意到这跟Y的表示有轻微的不同。事实上，我们需要能快速删除和添加行到每列，这就是为什么我们使用集合。另一方面，高德纳没有提到这点，实际上整个算法中所有行是保持不变的。</p><p>以下是算法的代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(X, Y, solution=[])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> X:</span><br><span class="line">        <span class="keyword">yield</span> list(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = min(X, key=<span class="keyword">lambda</span> c: len(X[c]))</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> list(X[c]):</span><br><span class="line">            solution.append(r)</span><br><span class="line">            cols = select(X, Y, r)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> solve(X, Y, solution):</span><br><span class="line">                <span class="keyword">yield</span> s</span><br><span class="line">            deselect(X, Y, r, cols)</span><br><span class="line">            solution.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(X, Y, r)</span>:</span></span><br><span class="line">    cols = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> Y[r]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> X[j]:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> Y[i]:</span><br><span class="line">                <span class="keyword">if</span> k != j:</span><br><span class="line">                    X[k].remove(i)</span><br><span class="line">        cols.append(X.pop(j))</span><br><span class="line">    <span class="keyword">return</span> cols</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deselect</span><span class="params">(X, Y, r, cols)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> reversed(Y[r]):</span><br><span class="line">        X[j] = cols.pop()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> X[j]:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> Y[i]:</span><br><span class="line">                <span class="keyword">if</span> k != j:</span><br><span class="line">                    X[k].add(i)</span><br></pre></td></tr></table></figure><p>真的只有 30 行！</p><h2 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h2><p>在解决实际问题前，我们需要将输入转换为上面描述的格式。可以这样简单处理</p><pre class="brush: python; gutter: false">X = {j: set(filter(lambda i: j in Y[i], Y)) for j in X}</pre><p>但这样太慢了。假如设 X 大小为 m，Y 的大小为 n，则迭代次数为 m*n。在这例子中的数独格子大小为 N，那需要 N^5 次。我们有更好的办法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = &#123;j: set() <span class="keyword">for</span> j <span class="keyword">in</span> X&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Y:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> Y[i]:</span><br><span class="line">        X[j].add(i)</span><br></pre></td></tr></table></figure><p>这还是 O(m*n) 的复杂度，但是是最坏情况。平均情况下它的性能会好很多，因为它不需要遍历所有的空格位。在数独的例子中，矩阵中每行恰好有 4 个条目，无论大小，因此它有N^3的复杂度。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>简单: </strong>不需要构造复杂的数据结构，所有用到的结构Python都有提供。</li><li><strong>可读性: </strong>上述第一个例子是直接从<a href="http://en.wikipedia.org/wiki/Exact_cover#Detailed_example" target="_blank" rel="noopener">Wikipedia上的范例</a>直接转录下来的！</li><li><strong>灵活性: </strong>可以很简单得扩展来解决数独。</li></ul><h2 id="求解数独"><a href="#求解数独" class="headerlink" title="求解数独"></a>求解数独</h2><p>我们需要做的就是把数独描述成精确覆盖问题。<a href="http://www.cs.mcgill.ca/~aassaf9/python/sudoku.txt" target="_blank" rel="noopener">这里</a>有完整的数独解法代码，它能处理任意大小，3x3，5x5，即使是2x3，所有代码少于100行，并包含doctest！（感谢Winfried Plappert 和 David Goodger的评论和建议）</p>]]></content>
    
    <summary type="html">
    
      30 行 Python 代码搞定 X 算法
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="game" scheme="http://huangwei.pro/tags/game/"/>
    
      <category term="random" scheme="http://huangwei.pro/tags/random/"/>
    
      <category term="distribution" scheme="http://huangwei.pro/tags/distribution/"/>
    
      <category term="algorithm" scheme="http://huangwei.pro/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>百度面试题 - 搜索框的suggestion</title>
    <link href="http://huangwei.pro/2012-09/baidu-suggestion/"/>
    <id>http://huangwei.pro/2012-09/baidu-suggestion/</id>
    <published>2012-09-22T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><hr><p>百度搜索框的suggestion,比如输入北京，搜索框下面会以北京为前缀，展示“北京爱情故事”、“北京公交”、“北京医院”等等搜索词。</p><p>如何设计使得空间和时间复杂度尽量低。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><hr><p>在字符串集合$ S $中，找出相同前缀$ P $的字符串。<br>设$ size(S) = N $，查询次数为$ M $。</p><h3 id="1-朴素方案"><a href="#1-朴素方案" class="headerlink" title="1. 朴素方案"></a>1. 朴素方案</h3><p>朴素得，每次查询时，遍历整个字符串集合，比较每个字符串的前缀。</p><p>时间复杂度$ T(N*len(P)) = O(N) $，这里的len(P)是一个常数值，所以不会对大O造成影响，参见<a href="http://zh.wikipedia.org/zh/%E5%A4%A7O%E7%AC%A6%E5%8F%B7" title="大O符号 - 维基百科，自由的百科全书" target="_blank" rel="noopener">扩展阅读1</a>。</p><p>那总的时间复杂度就是$ O(MN) $，不使用额外空间，则空间复杂度为$ O(1) $。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> Si <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">if</span> prefix(Si, P):</span><br><span class="line">        <span class="keyword">print</span> Si</span><br></pre></td></tr></table></figure><h3 id="2-离线处理方案"><a href="#2-离线处理方案" class="headerlink" title="2. 离线处理方案"></a>2. 离线处理方案</h3><p>想一下方案1，我们大部分时间浪费在了很多不可能的比较上。<br>如，字符串集合中有“南京”，“上海青年”等，跟“北京”前缀毫无关系的词。</p><p>为了优化这部分计算，我们先对字符串集合进行排序，然后二分查找到前缀相关位置，接着遍历，如果遇上没有该前缀的词，就可以停止遍历。</p><p>因为后续的词不可能再有相关前缀，这一特性是字典序后的集合保证的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort(S)</span><br><span class="line">i = lower_bound(S, P)</span><br><span class="line"><span class="keyword">for</span> i = i to N:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prefix(S[i], P):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> S[i]</span><br></pre></td></tr></table></figure><p>排序是在第一次查询前先预处理的，后续不需再调用。</p><p>假设每次查询获得条目数为R，所以时间复杂度$ T(NlogN + M(logN + R)) $。</p><p>但我们这里定义$R$为常量，因为真实应用上显示条目上限是有限制的，像baidu就只有10个。</p><p>那时间复杂度就是$ O(NlogN + MlogN) $。<br>集合S在这个方案中最好使用数组保存，随机读写效率高。<br>当然也能使用自平衡树，如<code>std::set</code>，<mark>虽然set排序也是$ O(NlogN) $，但由于其结构的复杂性，实际效率会有几倍的差弱于快排。</mark></p><h3 id="3-在线处理方案"><a href="#3-在线处理方案" class="headerlink" title="3. 在线处理方案"></a>3. 在线处理方案</h3><h4 id="3-1-字典树"><a href="#3-1-字典树" class="headerlink" title="3.1 字典树"></a>3.1 字典树</h4><p>离线跟在线最大的区别，在于离线的字符串集合S是固定，而在线的话集合S会有增加、删除、更新操作。</p><p>所以在线处理的难度大于离线，离线问题可以认为是在线问题的子集。</p><p>假如在$M$次查询过程中，加入$L$次更新操作。在直接套用离线处理方案的情况下，时间复杂度为$ O(LNlogN + MlogN) $。</p><p>显然这时查询不是瓶颈，反而预处理拖了后腿。</p><p>这里，我们推荐使用Trie（<a href="http://zh.wikipedia.org/zh/Trie" title="Trie - 维基百科，自由的百科全书" target="_blank" rel="noopener">字典树</a>），为什么选择字典树？因为它满足这些需求：</p><ol><li>==更新和查找操作与字符串长度有关，时间复杂度O(1)==，保证了效率。</li><li>==树的遍历顺序隐含了字典顺序==，不需显式排序，跳过预处理瓶颈。</li></ol><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_prefix</span><span class="params">(node, deep)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> empty(node):                <span class="comment">#子树为空</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> deep == len(P):            <span class="comment">#找到完整P</span></span><br><span class="line">        <span class="keyword">return</span> all_son(node)    <span class="comment">#返回该子树所有叶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#递归遍历子树</span></span><br><span class="line">    find_prefix(son(node, P[deep]), deep+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Trie处理流程大致是这样的，单次查询的时间复杂度为$O(1)$。</p><p>在线的处理方式当然也能用在离线上，但这两者的效率谁高谁低？</p><p>从时间复杂度上，$O(logN)$对$O(1)$，似乎没有啥可比性，但在实践中我们要考虑一些其他因素。 </p><p>首先，数组的下标访问速度优于树的指针访问（关于这点大家可以反汇编，不要迷信教科书上指针访问必定快于下标访问的结论，这点效率虽然有差，但现代编译器会很好的优化相关代码）。 </p><p>其次，获取结果的效率，数组的顺序访问也优于树的遍历。树有中间节点的时间消耗，且数组能比较好得被Cache到。 </p><p>再者，即使 $ N = 1G = 2^{30} $ ， $ logN = 30 $ 而已， $ O(logN) $ 数量级和$O(1)$相比其实不算多坏。 </p><p>使用数组的方案在实际情况下，往往表现优于Trie，而且程序编写难度低，调试方面也相对轻松。 </p><p>最最关键的是，Trie在工程上应用面很窄，根本不像其在理论上来的那样强大。 </p><p>==朴素的Trie一般应用在英文场景，数据集庞大且重复率很高的情况下比较适用。==</p><p>原因就是 ==Trie太费内存，不能应用于中文。== 基本上可以说，不改造不优化，Trie就是废材。 </p><p>但Trie多路查找的思想确实很重要，很多变种能得到很好的时空效率。 </p><p>有些程序员会迷恋甚至迷信各种数据结构在理论上带来的结果，其实我们更应该看清本质，这也是我想写有深度的分析稿子的原因。 </p><p>关于Trie的优化和改造相关内容，我会再整理一份稿子奉上的，这里先作为一个案例引用。</p><h4 id="3-2-改造方案"><a href="#3-2-改造方案" class="headerlink" title="3.2 改造方案"></a>3.2 改造方案</h4><p>现在的问题是，在线处理我们需要像Trie这样的多路查找树特性，而且要能支持中文。 </p><p>这里我们可以转换下思路，可以把中文转换成拼音，这样又可以直接套用Trie，只不过多了中文转拼音一个步骤。 </p><p>转拼音其实不难，就是做个表进行映射下就好了，GBK2.0标准中也就27000+个汉字，处理详细方法在这不累述，请自行google。</p><p><img src="http://pic002.cnblogs.com/images/2012/157422/2012092418501755.png" alt=""></p><p>如上图，朴素的Trie是按英文字母做边的，而拼音是声母和韵母作为单元。 </p><p>比如“好”hao，“双”shuang， ==Tire的做法会使树中间节点冗余，影响查找效率，最重要的是导致内存浪费。== </p><p>优化方法是将Trie对英文字母的映射改成声母和韵母的映射。 </p><p>哈，这个说起来简单，实现起来还是有要注意的地方。 </p><p>Trie对字母的映射，可以简单得开个数组，类似ptr[26]，然后映射就很简单，比如ptr[ch-‘a’]。 </p><p>而声母和韵母的映射没这么简单，一般方法就是枚举、二分查找、map、hash，虽然集合不大，但或多或少都需要耗费些时间。 </p><p>但这个是为减少空间浪费做的一点点时间牺牲，在工程实践上是完全值得的。</p><p><img src="http://pic002.cnblogs.com/images/2012/157422/2012092419063236.png" alt=""></p><p>有童鞋会说，既然声母和韵母还是要映射，为什么不直接映射中文？ </p><p>==其实不映射中文的原因，在于中文处理本身有难度，字符集大，词组间相同前缀较短，容易给树结构的内存问题雪上加霜。== </p><p>用拼音的方法，容易合并相关前缀，比如同音不同字的情况。 </p><p>当然这些空间优势也需要付出一定的时间花费，就是在节点上保存相关词组。 </p><p>比如图例中的shuang，它可能是“双”，也可能是“爽”。这在查询前缀较短的情况下，词组候选集过大，导致额外的性能瓶颈。 </p><p>说到这里的时候，大家可能有点迷糊了，既然中文的查找树太费内存不可用，而拼音的查找树又会退化，那怎么解决才好？ </p><p>在这，我想表明我自己的一个观点，就是特定的复杂的应用应该有量身定做的算法和数据结构，教科书上不可能有现成的方案。所以一个优秀程序员的必经之路，必须要能融会贯通，然后构建出自己的解决方案。</p><p>概括下我的思路。对于有更新的在线处理，我们如果采用多路查找树的思想（我这不提Trie了，因为Trie已经被改造的面目全非），可以既照顾到数据集的更新也能兼顾查询效率，两者的时间复杂度都和操作的字符串长度有关，这已是极小的时间花费。 </p><p>从汉字转为拼音，虽然无法直接映射汉字，导致同音词查询新子问题的出现，但换来了空间可用性。 </p><p>因而打开了一种新的思路，在这里 ==拼音做了类似一级索引的工作，同音字的筛选就能在小数据集中操作。==</p><p><img src="http://pic002.cnblogs.com/images/2012/157422/2012092514564342.png" alt=""></p><p>上图中，红色表示一级索引，绿色表示二级索引，蓝色表示数据集（蓝色是冗余数据优化），不同的图形表示不同的数据结构。这样在工程上的好处是可以结合多个不同数据结构各自的优点。 </p><p>一级索引查找方式类似Trie，二级索引可以使用set、map、hash等关联结构，数据集可以使用list、vector等顺序结构。 </p><p>使用STL的童鞋可以在(资料)<a href="http://www.sgi.com/tech/stl/table_of_contents.html" title="SGI - the Standard Template Library" target="_blank" rel="noopener">3</a>中查询各种结构的用法。</p><h4 id="3-3改造方案优化"><a href="#3-3改造方案优化" class="headerlink" title="3.3改造方案优化"></a>3.3改造方案优化</h4><p>我们来分析下复杂度，首先分析查询时间复杂度（不算蓝色优化部分）。 </p><p>一级索引查找时间跟前缀拼音长度有关$T(Len(P))$。子树遍历跟其大小有关，最坏能到达$O(N)$。</p><p>==遍历子树是多路查找树的通病，因为它的中间节点不保存子节点信息，当然你可以选择冗余保存（就是蓝色的功能）。==</p><p>离线处理时我们说过，实践中结果集R会是一个常数值，所以别担心$O(N)$，这里我们换成$T(R)$来计算。 </p><p>当一级索引节点有匹配时，进入二级索引，这里我们使用STL的set结构来分析。</p><p>set使用iterator遍历时，它是字典序的，所以使用lower_bound + iterator就能搞定，时间复杂度是$O(logN) + T(R)$。 </p><p>最坏情况下，每个有效节点（除去不完整的拼音节点）只有一个词，这样需要遍历R个有效节点。</p><p>时间复杂度为$Len(P) + R<em>(O(logN) + R) = Len(P) + R</em>O(logN) + R*R$，<br>因为$Len(P)$和$R$都是常数值，所以最后查询的时间复杂度为$O(logN)$。 </p><p>插入操作的流程跟查询类似，时间复杂度也相同，在这就略过了。 </p><p>从这个角度讲，大家 ==不要太过于迷信大O分析，这只是很粗略的上界，它保证时间效率上的可用性，不代表它的实际运行效率。==</p><p>所以，见到$O(logN)$跑的比$O(N^2)$都慢的程序也是很正常的，很多细节的优化，往往都是根据相关数据和特点在大O系数和常数间挣扎。</p><h4 id="3-4-自平衡树"><a href="#3-4-自平衡树" class="headerlink" title="3.4 自平衡树"></a>3.4 自平衡树</h4><p>估计很多童鞋看上字典树的处理方案已经很头大了，有没有又方便又快捷的方案？ </p><p>当然有，离线处理我们提到过自平衡树，如<code>std::set</code>, <code>std::map</code>。 </p><p>在线处理中就很好的用到了它的插入特性，时间复杂度为$O(logN)$。 </p><p>然后依然使用lower_bound + iterator方法查询。 </p><p>这样它的插入和查询也都是$O(logN)$，那上面的方案跟平衡树方案效率是等同的？ </p><p>此时，我希望大家能从字典树的复杂度分析过程中找到些灵感，这里我不详述红黑树理论，可<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree" title="Red–black tree - Wikipedia, the free encyclopedia" target="_blank" rel="noopener">参见资料</a>。</p><h2 id="引用资料"><a href="#引用资料" class="headerlink" title="引用资料"></a>引用资料</h2><hr><p>[1] <a href="http://zh.wikipedia.org/zh/%E5%A4%A7O%E7%AC%A6%E5%8F%B7" title="大O符号 - 维基百科，自由的百科全书" target="_blank" rel="noopener">大O符号 - 维基百科，自由的百科全书</a></p><p>[2] <a href="http://zh.wikipedia.org/zh/Trie" title="Trie - 维基百科，自由的百科全书" target="_blank" rel="noopener">Trie - 维基百科，自由的百科全书</a></p><p>[3] <a href="http://www.sgi.com/tech/stl/table_of_contents.html" title="SGI - the Standard Template Library" target="_blank" rel="noopener">SGI - the Standard Template Library</a></p><p>[4] <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree" title="Red–black tree - Wikipedia, the free encyclopedia" target="_blank" rel="noopener">Red–black tree - Wikipedia, the free encyclopedia</a></p>]]></content>
    
    <summary type="html">
    
      百度搜索框的suggestion,比如输入北京，搜索框下面会以北京为前缀，展示“北京爱情故事”、“北京公交”、“北京医院”等等搜索词。
    
    </summary>
    
      <category term="algorithm" scheme="http://huangwei.pro/categories/algorithm/"/>
    
    
      <category term="trie" scheme="http://huangwei.pro/tags/trie/"/>
    
      <category term="string" scheme="http://huangwei.pro/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>Windows Socket IO 模型</title>
    <link href="http://huangwei.pro/2010-11/winsockio/"/>
    <id>http://huangwei.pro/2010-11/winsockio/</id>
    <published>2010-11-20T16:00:00.000Z</published>
    <updated>2016-04-14T08:48:03.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字架构"><a href="#套接字架构" class="headerlink" title="套接字架构"></a>套接字架构</h2><hr><p><img src="/static/img/winsock1.gif" alt="图1"></p><p>应用程序使用Winsock与传输协议驱动沟通时AFD.SYS负责缓冲区的管理。这就意味着当一个程序调用send或者WSASend发送数据时，数据将被复制到AFD.SYS它自己的内部缓冲区中（依赖SO_SNDBUF的设置）WSASend调用立即返回。然后AFD.SYS在程序后台将数据发送出去。当然，如果程序想要处理一个比SO_SNDBUF设置的缓冲区需求更大的发送请求，WSASend的调用就会阻塞直到所有的数据都被发送出去。</p><p>类似的，从远程客户端接收数据时，只要SO_RCVBUF设置的缓冲区还没有满，AFD.SYS就会将数据复制进它自己的缓冲区直到所有的发送都已完成。当程序调用recv或者是WSARecv，数据就从AFD.SYS的缓冲区复制到了程序提供的缓冲区中了。</p><a id="more"></a><p>使用Winsock的时候还会间接碰到另外两种资源的限制。第一个页面锁定的限制。注意重叠操作可能偶然性地以ERROR_INSUFFICIENT_RESOURCES调用失败，这基本上意味着有太多的发送和接收操作在等待中。另外一个限制是操作系统的非分页池（non-paged pool）的限制。</p><h3 id="阻塞模型"><a href="#阻塞模型" class="headerlink" title="阻塞模型"></a>阻塞模型</h3><table><br><tr><br><td><br><br><pre class="prettyprint lang-cpp"><br>int recv(<br>SOCKET s,<br>char<em> buf,<br>int len,<br>int flags<br>);<br></em></pre><br><br></td><br><td><br><br><pre class="prettyprint lang-cpp"><br>int send(<br>SOCKET s,<br>const char buf,<br>int len,<br>int flags<br>);<br></pre><br><br></td><br></tr><br></table><p>这种方式最为大家熟悉，Socket默认的就是阻塞模式。</p><p>在recv的时候，Socket会阻塞在那里，直到连接上有数据可读，把数据读到buffer里后recv函数才会返回，不然就会一直阻塞在那里。</p><p>如果在主线程中被阻塞，而数据迟迟没有过来，那么程序就会被锁死。这样的问题可以用多线程解决，但是在有多个套接字连接的情况下，这不是一个好的选择，扩展性很差，而且也容易有锁的问题。线程过多，也导致上下文切换过于频繁，导致系统变慢，而且大部分线程是处于非活动状态的话，这就大大浪费了系统的资源。</p><h3 id="非阻塞模型"><a href="#非阻塞模型" class="headerlink" title="非阻塞模型"></a>非阻塞模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctlsocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">IN <span class="keyword">long</span> cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT u_long FAR * argp</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIONBIO <span class="comment">/* set/clear non-blocking i/o */</span></span></span><br></pre></td></tr></table></figure><p>调用ioctlsocket函数设置FIONBIO为1就转为非阻塞模式。</p><p>当recv和send函数没有准备好数据时，函数不会阻塞，立即返回错误值，用GetLastError返回的错误码为WSAEWOULDBLOCK，中文解释为“无法立即完成一个非阻挡性套接字的操作”。</p><p>当然，这里你可以用非阻塞模拟阻塞模式，就是用while循环不停调用recv，直到recv返回成功为止。这样的效率也不高，但好处在于你能在没接收到数据时，有空进行其他操作，或者直接Sleep。</p><h3 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set* readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set* writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set* exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct timeval* timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Select模型是非阻塞的，函数内部自动检测WSAEWOULDBLOCK状态，还能有超时设定。对read，write，except三种事件进行分别检测，except指带外数据可读取，read和write的定义是广义的，accept，close等消息也纳入到read。</p><p>Select函数使用fd_set结构，它的结构非常的简单，只有一个数组和计数器。<br>Timeval结构里可以设置超时的时间。</p><p>Select函数返回值表示集合中有事件触发的sock总数，其余操作使用fd_set的宏来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE      64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* FD_SETSIZE */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span></span><br><span class="line">u_int fd_count;               <span class="comment">/* how many are SET? */</span></span><br><span class="line">SOCKET  fd_array[FD_SETSIZE];   <span class="comment">/* an array of SOCKETs */</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line">FD_CLR(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_ISSET(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_SET(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_ZERO(*<span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>Select模型流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd_set fdread;</span><br><span class="line">timeval tv = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化fd_set</span></span><br><span class="line">    FD_ZERO(&amp;fdread);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nSock; i ++)</span><br><span class="line">        FD_SET(socks[i], &amp;fdread);</span><br><span class="line">    <span class="comment">// 等待事件触发，或超时返回</span></span><br><span class="line">    <span class="keyword">int</span> ret = select(<span class="number">0</span>, &amp;fdread, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ret &gt; <span class="number">0</span> &amp;&amp; i &lt; nSock; i ++)</span><br><span class="line">        <span class="comment">// 检测哪个sock有事件触发</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(socks[i], &amp;fdread)) &#123;</span><br><span class="line">            read_buf(socks[i]);</span><br><span class="line">            ret --;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实select的原理就是对sock集合进行扫描，有事件或者超时则退出，所以select的效率也是和sock数量成线性关系，而且需要我们自己循环检查哪个sock有事件发生。</p><p>它的优点是模型简单，过程清晰，容易管理，支持多个sock服务。缺点也很明显，本质还是个循环的改进版本，而且fd_set里最多只能放64个sock，还有它无法很好的支持sock事件的先后顺序。</p><h3 id="WSAAsynSelect模型"><a href="#WSAAsynSelect模型" class="headerlink" title="WSAAsynSelect模型"></a>WSAAsynSelect模型</h3><p>WSAAsynSelect是Windows特有的，可以在一个套接字上接收以Windows消息为基础的网络事件通知。该模型的实现方法是通过调用WSAAsynSelect函数自动将套接字设置（转变）为非阻塞模式，并向Windows注册一个或多个网络事件lEvent，并提供一个通知时使用的窗口句柄hWnd。当注册的事件发生时，对应的窗口将收到一个基于消息的通知wMsg。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> wMsg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> lEvent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>WSAAsyncSelect模型流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_SOCKET WM_USER+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hINstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    SOCKET Listen;</span><br><span class="line">    HWND Window;</span><br><span class="line">    <span class="comment">// 创建窗口，绑定上WinProc</span></span><br><span class="line">    <span class="comment">// 创建sock</span></span><br><span class="line">    WSAStartup(…);</span><br><span class="line">    Listen = Socket();</span><br><span class="line">    bind(…);</span><br><span class="line">    WSAAsyscSelect(Listen, Window, WM_SOCKET, FD_ACCEPT | FD_CLOSE);</span><br><span class="line">    listen(Listen, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">WinProc</span><span class="params">(HWND hDlg, WORD wMsg, WORD wParam, DWORD lParam)</span> </span>&#123;</span><br><span class="line">    SOCKET Accept;</span><br><span class="line">    <span class="keyword">switch</span>(wMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_SOCKET:</span><br><span class="line">        <span class="comment">// lParam的高字节包含了可能出现的任何的错误代码</span></span><br><span class="line">        <span class="comment">// lParam的低字节指定已经发生的网络事件</span></span><br><span class="line">        <span class="comment">// 发生错误</span></span><br><span class="line">        <span class="keyword">if</span>(WSAGETSELECTERROR(lParam)) &#123;</span><br><span class="line">            closesocket…</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 事件触发</span></span><br><span class="line">        <span class="keyword">switch</span>( WSAGETSELECTEVENT(lParam) ) &#123;</span><br><span class="line">            <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">            <span class="keyword">case</span> FD_READ:</span><br><span class="line">            <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WSAAsyncSelect是模仿Windows消息机制来实现的，使用起来很方便，仅仅只是在消息处理中加入了对WM_SOCKET的处理，这样就能严格得按先后顺序处理sock事件。</p><p>MFC中的CSOCKET也采用了这个模型。</p><p>lEvent事件表：</p><table><thead><tr><th style="text-align:left">Event</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">FD_READ</td><td style="text-align:left">应用程序想要接收有关是否可读的通知，以便读入数据</td></tr><tr><td style="text-align:left">FD_WRITE</td><td style="text-align:left">应用程序想要接收有关是否可写的通知，以便写入数据</td></tr><tr><td style="text-align:left">FD_OOB</td><td style="text-align:left">应用程序想接收是否有带外（OOB）数据抵达的通知</td></tr><tr><td style="text-align:left">FD_ACCEPT</td><td style="text-align:left">应用程序想接收与进入连接有关的通知</td></tr><tr><td style="text-align:left">FD_CONNECT</td><td style="text-align:left">应用程序想接收与一次连接或者多点join操作完成的通知</td></tr><tr><td style="text-align:left">FD_CLOSE</td><td style="text-align:left">应用程序想接收与套接字关闭有关的通知</td></tr><tr><td style="text-align:left">FD_QOS</td><td style="text-align:left">应用程序想接收套接字“服务质量”（QoS）发生更改的通知</td></tr><tr><td style="text-align:left">FD_GROUP_QOS</td><td style="text-align:left">应用程序想接收套接字组“服务质量”发生更改的通知（现在没什么用处，为未来套接字组的使用保留）</td></tr><tr><td style="text-align:left">FD_ROUTING_INTERFACE_CHANGE</td><td style="text-align:left">应用程序想接收在指定的方向上，与路由接口发生变化的通知</td></tr><tr><td style="text-align:left">FD_ADDRESS_LIST_CHANGE</td><td style="text-align:left">应用程序想接收针对套接字的协议家族，本地地址列表发生变化的通知</td></tr></tbody></table><p>只有在以下3种条件下，会发送FD_WRITE事件：</p><ul><li>使用connect。连接首次被建立。</li><li>使用accept。套接字被接受。</li><li>使用send，sendto。</li></ul><p>它的缺点就是，每个sock事件处理需要一个窗口句柄，如果sock很多的情况下，资源和性能可想而知了。</p><h3 id="WSAEventSelect模型"><a href="#WSAEventSelect模型" class="headerlink" title="WSAEventSelect模型"></a>WSAEventSelect模型</h3><p>WSAEventSelect模型类似WSAAsynSelect模型，但最主要的区别是网络事件发生时会被发送到一个Event对象句柄，而不是发送到一个窗口。这样你就可以使用Event对象的特性了。但WSAEventSelect模型明显复杂很多。</p><p>它需要由以下函数一起完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建事件对象来接收网络事件：</span></span><br><span class="line"><span class="function">WSAEVENT <span class="title">WSACreateEvent</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="comment">// 2. 将事件对象与套接字关联，同时注册事件，使事件对象的工作状态从未传信转变未已传信。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAEventSelect</span><span class="params">( SOCKET s,WSAEVENT hEventObject,<span class="keyword">long</span> lNetworkEvents )</span></span>;</span><br><span class="line"><span class="comment">// 3. I/O处理后，设置事件对象为未传信</span></span><br><span class="line"><span class="function">BOOL <span class="title">WSAResetEvent</span><span class="params">( WSAEVENT hEvent )</span></span>;</span><br><span class="line"><span class="comment">// 4. 等待网络事件来触发事件句柄的工作状态：</span></span><br><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">( DWORD cEvents,<span class="keyword">const</span> WSAEVENT FAR * lphEvents, BOOL fWaitAll,DWORD dwTimeout, BOOLfAlertable )</span></span>;</span><br><span class="line"><span class="comment">// 5.  获取网络事件类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAEnumNetworkEvents</span><span class="params">( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents )</span></span>;</span><br></pre></td></tr></table></figure><p>WSACreateEvent其实跟CreateEvent的效果类似，返回的WSAEVENT类型其实就是HANDLE类型，所以可以直接使用CreateEvent创建特殊的Event。</p><p>sock和Event对象是对应的，当一个套接字有事件发生，WSAWaitForMultipleEvents返回相应的值，通过这个值来索引这个套接字。 但它也和select一样，在Event数组大小上也有限制，MAXIMUM_WAIT_OBJECTS的值为64。</p><p>有了Event对象的支持，signaled/non-signaled和manual reset/auto reset的概念也就可以应用到程序里，这样能使sock事件处理的方式比较丰富灵活。而且它也能严格按先后顺序处理sock事件。</p><p>闪电邮PushMail的处理就是WSAEventSelect模型。</p><h3 id="Over-Lapped-IO模型"><a href="#Over-Lapped-IO模型" class="headerlink" title="Over-Lapped IO模型"></a>Over-Lapped IO模型</h3><p>它和之前模型不同的是，使用重叠模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。之前的模型都是在套接字的缓冲区中，当通知应用程序接收后，在把数据拷贝到程序的缓冲区。</p><p>这种模型适用于除WindowsCE外的其他Windows平台，该模型是以Windows的重叠IO机制为基础，通过ReadFile和WriteFile，针对设备执行IO操作。</p><p>早先这种机制是用于文件IO，在Socket IO和文件IO统一接口之后，这种机制也被引入Socket IO。但这类模型的实现就相对复杂多了。</p><p>有两个方法可以实现重叠IO请求的完成情况（接到重叠操作完成的通知）：</p><ul><li>事件对象通知（event object notification）。</li><li>完成例程（completion routines）。注意，这里并不是完成端口。</li></ul><h4 id="WSAOVERLAPPED"><a href="#WSAOVERLAPPED" class="headerlink" title="WSAOVERLAPPED"></a>WSAOVERLAPPED</h4><p>重叠结构是不得不提的，之后的完成端口模型也需要用到。这个结构等同于OVERLAPPED。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WSAOVERLAPPED</span> &#123;</span></span><br><span class="line">DWORD Internal;</span><br><span class="line">DWORD InternalHigh;</span><br><span class="line">DWORD Offset;</span><br><span class="line">DWORD OffsetHigh;</span><br><span class="line">WSAEVENT hEvent; <span class="comment">// 只关注这个参数，用来关联WSAEvent对象</span></span><br><span class="line">&#125; WSAOVERLAPPED, *LPWSAOVERLAPPED;</span><br></pre></td></tr></table></figure><p>使用重叠结构，我们常用的send, sendto, recv, recvfrom也都要被WSASend, WSASendto, WSARecv, WSARecvFrom替换掉了，是因为它们的参数中都有一个Overlapped参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SOCKET s, <span class="comment">// [in] 套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPWSABUF lpBuffers, <span class="comment">// [in,out] 接收缓冲区，WSABUF的数组</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwBufferCount, <span class="comment">// [in] 数组中WSABUF的数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpNumberOfBytesRecvd, <span class="comment">// [out] 此刻函数所接收到的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpFlags,             <span class="comment">// [in,out] 这里设置为0 即可</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPWSAOVERLAPPED lpOverlapped,  <span class="comment">// [in] 绑定重叠结构</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// [in] 完成例程中将会用到的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>没有错误且收取立刻完成时，返回值为0，否则是SOCKET_ERROR。常见的错误码是WSA_IO_PENDING，表示重叠操作正在进行。相应的其他函数也是类似参数，具体参考MDSN。</p><p>获取重叠操作的结果，由WSAWaitForMultipleEvents函数来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WSAGetOverlappedResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SOCKET s, <span class="comment">// [in] 套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPWSAOVERLAPPED lpOverlapped, <span class="comment">// [in] 要查询的重叠结构的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpcbTransfer,<span class="comment">// [out] 本次重叠操作的实际接收(或发送)的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">BOOL fWait, <span class="comment">// [in] 设置为TRUE，除非重叠操作完成，否则函数不会返回</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 设置FALSE，而且操作仍处于挂起状态，那么函数就会返回FALSE，错误为WSA_IO_INCOMPLETE</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpdwFlags <span class="comment">// [out] 负责接收结果标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h4><p>事件等待函数和WaitForMultipleObjects类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD cEvents, <span class="comment">// [in] 等候事件的总数量</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> WSAEVENT* lphEvents, <span class="comment">// [in] 事件数组的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">BOOL fWaitAll, <span class="comment">// [in] 是否等待所有事件</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwTimeout, <span class="comment">// [in] 超时时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">BOOL fAlertable <span class="comment">// [in] 在完成例程中会用到这个参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值有这么几个：</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>WSA_WAIT_TIMEOUT</td><td>超时，我们要继续Wait</td></tr><tr><td>WSA_WAIT_FAILED</td><td>出现错误</td></tr><tr><td>WAIT_IO_COMPLETION</td><td>一个或多个完成例程入队列执行</td></tr><tr><td>WSA_WAIT_EVENT_0 ~ (WSA_WAIT_EVENT_0 + cEvents – 1)</td><td>触发的事件下标</td></tr></tbody></table><p>事件通知的重叠IO模型大致流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立并初始化buf和overlap</span></span><br><span class="line">WSAOVERLAPPED Overlap;</span><br><span class="line">WSABUF DataBuf;</span><br><span class="line"><span class="keyword">char</span>* SendBuf = <span class="keyword">new</span> <span class="keyword">char</span>[BufLen];</span><br><span class="line">DWORD Flags = <span class="number">0</span>;</span><br><span class="line">DataBuf.len = BufLen;</span><br><span class="line">DataBuf.buf = SendBuf;</span><br><span class="line">Overlap.hEvent = EventArray[dwEventTotal ++] = WSACreateEvent();</span><br><span class="line"><span class="comment">// 2. 在套接字上投递WSARecv请求</span></span><br><span class="line"><span class="keyword">int</span> ret = WSARecv(Sock, &amp;DataBuf, <span class="number">1</span>, &amp;NumberOfBytesRecvd,</span><br><span class="line">&amp;Flags, &amp;Overlap, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING)</span><br><span class="line">error_handle(…);</span><br><span class="line"><span class="comment">// 3. 等待事件通知</span></span><br><span class="line">DWORD dwIndex = WSAWaitForMultipleEvents(dwEventTotal,EventArray,     FALSE, WSA_INFINITE, FALSE);</span><br><span class="line"><span class="keyword">if</span> (dwIndex == WSA_WAIT_FAILED || dwIndex == WSA_WAIT_TIMEOUT)</span><br><span class="line">error_handle(…);</span><br><span class="line">dwIndex -= WSA_WAIT_EVENT_0;</span><br><span class="line"><span class="comment">// 4. 重置事件对象</span></span><br><span class="line">WSAResetEvent(EventArray[dwIndex]);</span><br><span class="line"><span class="comment">// 5. 取得重叠调用的返回状态</span></span><br><span class="line">DWORD dwBytesTransferred;</span><br><span class="line">WSAGetOverlappedResult(Sock, Overlap, &amp;dwBytesTransferred, TRUE, &amp;Flags);</span><br><span class="line"><span class="keyword">if</span> (dwBytesTransferred == <span class="number">0</span>)</span><br><span class="line">closesocket(Sock);</span><br><span class="line">dosomething(…);</span><br></pre></td></tr></table></figure><p>如果是服务端使用事件通知模型，则需要再起一个线程来循环Wait事件通知，主线程则接受请求的连接。</p><p>实际编码过程中，要注意缓冲区不要搞错，因为全都需要自己来管理，稍有不慎就容易写脏数据和越界。还要注意WSARecv时，可能立即有数据返回的情况，即返回值为0且NumberOfBytesRecvd &gt; 0。</p><h4 id="完成例程"><a href="#完成例程" class="headerlink" title="完成例程"></a>完成例程</h4><p>完成例程（Completion Routine），不是完成端口。它是使用APC（Asynchronous Procedure Calls）异步回调函数来实现，大致流程和事件通知模型差不多，只不过WSARecv注册时，加上了lpCompletionRoutine参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void CALLBACK <span class="title">CompletionROUTINE</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwError, <span class="comment">// [in] 标志咱们投递的重叠操作完成的状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD cbTransferred, <span class="comment">// [in] 重叠操作期间，实际传输的字节量是多大</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPWSAOVERLAPPED lpOverlapped, <span class="comment">// [in] 传递到最初IO调用的重叠结构</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwFlags  <span class="comment">// [in] 返回操作结束时可能用的标志(一般没用)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>但完成例程有一个比较隐晦的地方，就是APC机制本身。</p><h5 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h5><p>ReadFileEx / WriteFileEx在发出IO请求的同时，提供一个回调函数（APC过程），当IO请求完成后，一旦线程进入可告警状态，回调函数将会执行。</p><p>以下五个函数能够使线程进入告警状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SleepEx</span><br><span class="line">WaitForSingleObjectEx</span><br><span class="line">WaitForMultipleObjectsEx</span><br><span class="line">SignalObjectAndWait</span><br><span class="line">MsgWaitForMultipleObjectsEx</span><br></pre></td></tr></table></figure><p>线程进入告警状态时，内核将会检查线程的APC队列，如果队列中有APC，将会按FIFO方式依次执行。如果队列为空，线程将会挂起等待事件对象。以后的某个时刻，一旦APC进入队列，线程将会被唤醒执行APC，同时等待函数返回WAIT_IO_COMPLETION。</p><p><img src="/static/img/winsock2.jpg" alt="图2"></p><p>回到完成例程的话题上。</p><p>需要一个辅助线程，辅助线程的工作是判断有没有新的客户端连接被建立，如果有，就为那个客户端套接字激活一个异步的WSARecv操作，然后调用SleepEx使线程处于一种可警告的等待状态，以使得I/O完成后 CompletionROUTINE可以被内核调用，而CompletionROUTINE会在当初激活WSARecv异步操作的代码的同一个线程之内！而且调用SleepEx时，需要把bAlertable参数设为TRUE，这样当有APC唤醒时立即调用完成例程，否则例程就不会被执行。当然也可以使用WSAWaitForMultipleEvents函数，但这样就需要一个事件对象。</p><p>从图中就能看到CompletionROUTINE是在辅助线程（调用过WSARecv）里执行的。</p><h3 id="Completion-Port模型"><a href="#Completion-Port模型" class="headerlink" title="Completion Port模型"></a>Completion Port模型</h3><p>“完成端口”模型是迄今为止最为复杂的一种I/O模型。</p><p>假若一个应用程序同时需要管理为数众多的套接字，那么采用这种模型，往往可以达到最佳的系统性能！它能最大限度的减少上下文切换的同时最大限度的提高系统并发量。但不幸的是，该模型只适用于Windows NT和Windows 2000操作系统。</p><p>因其设计的复杂性，只有在你的应用程序需要同时管理数百乃至上千个套接字的时候，而且希望随着系统内安装的CPU数量的增多，应用程序的性能也可以线性提升，才应考虑采用“完成端口”模型。</p><p>要记住的一个基本准则是，假如要为Windows NT或Windows 2000开发高性能的服务器应用，同时希望为大量套接字I/O请求提供服务（Web服务器便是这方面的典型例子），那么I/O完成端口模型便是最佳选择！</p><p>完成端口是一种WINDOWS内核对象。完成端口用于异步方式的重叠I/O。简单地，可以把完成端口看成系统维护的一个队列，操作系统把重叠IO操作完成的事件通知放到该队列里，由于是暴露 “操作完成”的事件通知，所以命名为“完成端口”（Completion Ports）。</p><p>完成端口内部提供了线程池的管理，可以避免反复创建线程的开销，同时可以根据CPU的个数灵活的决定线程个数，而且可以让减少线程调度的次数从而提高性能。</p><p><img src="/static/img/winsock3.gif" alt="图3"></p><p>它需要以下函数的支持，CreateIoCompletionPort函数用于创建和绑定完成端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE FileHandle, <span class="comment">// [in] IO句柄对象，这里是套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ExistingCompletionPort, <span class="comment">// [in] 完成端口</span></span></span></span><br><span class="line"><span class="function"><span class="params">ULONG_PTR CompletionKey, <span class="comment">// [in] 自定义数据指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD NumberOfConcurrentThreads <span class="comment">// [in] 最大线程数，0为自动</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>我们还需要类似WSAGetOverlappedResult的函数来获取完成端口的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE CompletionPort, <span class="comment">// [in] 完成端口</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpNumberOfBytes, <span class="comment">// [out] 此次IO操作的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">PULONG_PTR lpCompletionKey, <span class="comment">// [out] 自定义数据指针，CreateIoCompletionPort初始化的</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPOVERLAPPED* lpOverlapped, <span class="comment">// [out] 投递请求时的重叠结构指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwMilliseconds <span class="comment">// [in] 超时设置</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>还有PostQueuedCompletionStatus函数，能模拟一个完成的重叠I/O操作。我们可以当成类似PostMessage的函数，以此控制工作线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE CompletionPort, <span class="comment">// [in] 完成端口</span></span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwNumberOfBytesTransferred, <span class="comment">// [in] 此次IO操作的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">ULONG_PTR dwCompletionKey, <span class="comment">// [in] 自定义数据指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPOVERLAPPED lpOverlapped <span class="comment">// [in] 重叠结构指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>完成端口模型大致流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 参数设空，就能创建完成端口</span></span><br><span class="line">HANDLE CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 创建工作线程</span></span><br><span class="line">DWORD dwThreadId;</span><br><span class="line">SYSTEM_INFO sysinfo;</span><br><span class="line">GetSystemInfo(&amp;sysinfo);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sysinfo.dwNumberOfProcessors; i++)</span><br><span class="line">    CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, iocp_work_thread, CompletionPort, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"><span class="comment">// 3. 建立并初始化buf和overlap（参照重叠IO）</span></span><br><span class="line"><span class="comment">// 4. 将套接字绑定到完成端口</span></span><br><span class="line">CreateIoCompletionPort((HANDLE)Sock,CompletionPort,Sock,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 5. 在套接字上投递WSARecv请求（参照重叠IO）</span></span><br><span class="line"><span class="comment">// 6. 在工作线程中取本次I/O的相关信息</span></span><br><span class="line">GetQueuedCompletionStatus(CompletionPort,&amp;dwBytesTransferred,</span><br><span class="line">(DWORD*)&amp;Sock,(LPOVERLAPPED*)&amp;lpPerIOData,INFINITE);</span><br><span class="line"><span class="keyword">if</span> (dwBytesTransferred == <span class="number">0</span>)</span><br><span class="line">    closesocket(Sock);</span><br><span class="line">dosomething(…);</span><br></pre></td></tr></table></figure><h2 id="测试图例"><a href="#测试图例" class="headerlink" title="测试图例"></a>测试图例</h2><hr><p>来自于《Windows网络编程》的数据。</p><p><img src="/static/img/winsock4.jpg" alt="图4"></p><p>阻塞模型难以应对大规模的客户连接，因为它在创建线程上耗费了太多的系统资源。因此，服务器创建太多的线程后，再调用CreateThread函数时，将返回ERROR_NOT_ENOUGH_MEMORY的错误，那些发出连接请求的客户则收到WSAECONNREFUSED的错误提示，表示连接的尝试被拒绝。其并发处理量是极难突破的。</p><p>非阻塞模型和Select模型的性能要比阻塞模式稍好，但是占用了太多的CPU处理时间。瓶颈在于，fd_set集合的线性扫描上。还需要注意的一个问题就是，非分页池（即直接在物理内存中分配的内存）的使用极高。这是因为AFD（Ancillary Function Driver,由afd.sys提供的支持Windows Sockets应用程序的底层驱动程序，其中运行在内核模式下afd.sys驱动程序主要管理Winsock TCP/IP通信）和TCP都将使用I/O缓存，因为服务器读取数据的速度是有限的，相对于CPU的处理速度而言，I/O基本是零字节的吞吐量。</p><p>基于Windows消息机制的WSAAsyncSelect模型能够处理一定的客户连接量，但是扩展性也不是很好。因为消息泵很快就会阻塞，降低了消息处理的速度。在几次测试中，服务器只能处理大约1/3的客户端连接。过多的客户端连接请求都将返回错误提示码WSAECONNREFUSED。上表中的数据可以发现，对那些已经建立的连接，其平均吞吐量也是极低的。</p><p>基于事件通知的WSAEventSelect模型表现得出奇的不错。在所有的测试中，大多数时候，服务器基本能够处理所有的客户连接，并且保持着较高的数据吞吐量。这种模型的缺点是，每当有一个新连接时，需要动态管理线程池，因为每个线程只能够等待64个事件对象。但最后，服务器不能再接受更多的连接，原因是WSAENOBUFS（无可用的缓冲区空间），套接字无法创建。另外，客户端程序也达到了极限，不能维持已经建立的连接。</p><p>事件通知的重叠I/O模型和WSAEventSelect模型在伸缩性上差不多。这两种模型都依赖于等待事件通知的线程池，处理客户通信时，大量线程上下文的切换是它们共同的制约因素。重叠I/O模型和WSAEventSelect模型的测试结果很相似，都表现得不错，直到线程数量超过极限。</p><p>例程通知的重叠I/O模型，性能和事件通知的重叠I/O模型相同，但因为以下几个原因，也不是开发高性能服务器的最佳选择。首先，许多扩展功能不允许使用APC完成通知。其次，由于APC在系统内部特有的处理机制，应用程序线程可能无限等待而得不到完成通知。当一个线程处于“可警告状态”时，所有挂起的APC按照先进先出的顺序（FIFO）接受处理。</p><p>完成端口模型的是所有I/O模型中性能最佳的。内存使用率（包括用户分页池和非分页池）基本差不多。真正不同的地方，在于对CPU的占用。完成端口模型只占用了60%的CPU，但是在维持同样规模的连接量时，另外两种模型（基于事件通知的重叠I/O模型和WSAEventSelect模型）占用更多的CPU。完成端口的另外一个明显的优势是，它维持更大的吞吐量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><h3 id="客户端的选择"><a href="#客户端的选择" class="headerlink" title="客户端的选择"></a>客户端的选择</h3><p>为了能在一定程度上提升性能，建议使用重叠IO模型或者WSAEventSelect模型。</p><p>如果是窗口程序，且socket不多的情况下，可以使用WSAAsyncSelect模型。</p><p>当然，如果性能啥的都不需要考虑的，那简洁的Select模式值得被考虑。</p><h3 id="服务端的选择"><a href="#服务端的选择" class="headerlink" title="服务端的选择"></a>服务端的选择</h3><p>既然是服务端，必然要需要性能不错的。</p><p>重叠IO模型可以使你在给定的时间段内同时控制多个套接字。</p><p>但是，如果服务器在任意时间里都有大量IO请求，那就用完成端口模型。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ol><li>Windows核心编程;</li><li>手把手教你玩转SOCKET模型之重叠I/O篇;<br><a href="http://dev.csdn.net/htmls/39/39122.html" target="_blank" rel="noopener">http://dev.csdn.net/htmls/39/39122.html</a></li><li>手把手教你玩转网络编程模型之完成例程(Completion Routine)篇;<br><a href="http://blog.csdn.net/PiggyXP/archive/2009/02/19/3910726.aspx" target="_blank" rel="noopener">http://blog.csdn.net/PiggyXP/archive/2009/02/19/3910726.aspx</a></li><li>Windows Sockets 2.0: Write Scalable Winsock Apps Using Completion Ports;<a href="http://msdn.microsoft.com/zh-cn/magazine/cc302334(en-us" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/magazine/cc302334(en-us).aspx</a>.aspx)</li><li>Inside I/O Completion Ports;<a href="http://hi.baidu.com/jrckkyy/blog/item/401422527c131b070df3e37b.html" target="_blank" rel="noopener">http://hi.baidu.com/jrckkyy/blog/item/401422527c131b070df3e37b.html</a></li><li>Windows 2000 非分页池被 Afd.sys 耗尽;<a href="http://support.microsoft.com/kb/296265/zh-cn" target="_blank" rel="noopener">http://support.microsoft.com/kb/296265/zh-cn</a></li><li>WinSock五种I/O模型的性能分析;<a href="http://www.rover12421.com/2010/04/02/winsock%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">http://www.rover12421.com/2010/04/02/winsock%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      Windows Socket IO 的所有模型。
    
    </summary>
    
      <category term="develop" scheme="http://huangwei.pro/categories/develop/"/>
    
    
      <category term="socket" scheme="http://huangwei.pro/tags/socket/"/>
    
      <category term="windows" scheme="http://huangwei.pro/tags/windows/"/>
    
  </entry>
  
</feed>

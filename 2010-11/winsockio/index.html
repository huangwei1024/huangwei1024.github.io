<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Windows Socket IO 模型 | HuangWei&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="windows, socket, io, iocp, select, overlapped, WSAEventSelect, WSAAsynSelect">
  

  <meta name="description" content="Windows Socket IO 的所有模型。">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows Socket IO 模型">
<meta property="og:url" content="http://huangwei.pro/2010-11/winsockio/index.html">
<meta property="og:site_name" content="HuangWei's blog">
<meta property="og:description" content="Windows Socket IO 的所有模型。">
<meta property="og:image" content="http://huangwei.pro/static/img/winsock1.gif">
<meta property="og:image" content="http://huangwei.pro/static/img/winsock2.jpg">
<meta property="og:image" content="http://huangwei.pro/static/img/winsock3.gif">
<meta property="og:image" content="http://huangwei.pro/static/img/winsock4.jpg">
<meta property="og:updated_time" content="2016-04-14T08:48:03.569Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Windows Socket IO 模型">
<meta name="twitter:description" content="Windows Socket IO 的所有模型。">
<meta name="twitter:image" content="http://huangwei.pro/static/img/winsock1.gif">
  
    <link rel="alternative" href="/atom.xml" title="HuangWei&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://dn-huangweipro.qbox.me/static/favicon.ico">
  
  <link rel="stylesheet" href="http://dn-huangweipro.qbox.me/css/style.css">
  <link rel="stylesheet" href="http://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.min.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://dn-huangweipro.qbox.me/images/default_avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">HuangWei</a></h1>
		</hgroup>

		
		<p class="header-subtitle">That depends a good deal on where you want to get to</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/collections">好文收藏</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/huangwei1024" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/hwiskey" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-wei-1gb" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="http://www.douban.com/people/WisKey/" title="douban">douban</a>
					        
								<a class="mail" target="_blank" href="mailto:164305264@qq.com?subject=huangwei.pro读者来信" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/2d/" style="font-size: 12px;">2d</a> <a href="/tags/acm/" style="font-size: 14px;">acm</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/bloom-filter/" style="font-size: 10px;">bloom_filter</a> <a href="/tags/concrete-mathematics/" style="font-size: 18px;">concrete_mathematics</a> <a href="/tags/dev-log/" style="font-size: 10px;">dev-log</a> <a href="/tags/distribution/" style="font-size: 12px;">distribution</a> <a href="/tags/doom/" style="font-size: 10px;">doom</a> <a href="/tags/effective/" style="font-size: 10px;">effective</a> <a href="/tags/encryption/" style="font-size: 10px;">encryption</a> <a href="/tags/game/" style="font-size: 18px;">game</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/graph-theory/" style="font-size: 10px;">graph_theory</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/number-theory/" style="font-size: 20px;">number_theory</a> <a href="/tags/opengl/" style="font-size: 16px;">opengl</a> <a href="/tags/pathfinding/" style="font-size: 10px;">pathfinding</a> <a href="/tags/permutation/" style="font-size: 10px;">permutation</a> <a href="/tags/pixi/" style="font-size: 10px;">pixi</a> <a href="/tags/random/" style="font-size: 12px;">random</a> <a href="/tags/reading-notes/" style="font-size: 18px;">reading_notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/sight/" style="font-size: 10px;">sight</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/string/" style="font-size: 14px;">string</a> <a href="/tags/summary/" style="font-size: 14px;">summary</a> <a href="/tags/tree/" style="font-size: 12px;">tree</a> <a href="/tags/trie/" style="font-size: 14px;">trie</a> <a href="/tags/tutorials/" style="font-size: 16px;">tutorials</a> <a href="/tags/visibility/" style="font-size: 12px;">visibility</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a> <a href="/tags/zen/" style="font-size: 10px;">zen</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">前网易码农<br>现苦逼创业<br>轻微完美主义强迫症<br>努力提升个人魅力，强化自身修养</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">HuangWei</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://dn-huangweipro.qbox.me/images/default_avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">HuangWei</h1>
			</hgroup>
			
			<p class="header-subtitle">That depends a good deal on where you want to get to</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/collections">好文收藏</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/huangwei1024" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/hwiskey" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/huang-wei-1gb" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="http://www.douban.com/people/WisKey/" title="douban">douban</a>
			        
						<a class="mail" target="_blank" href="mailto:164305264@qq.com?subject=huangwei.pro读者来信" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-winsockio" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2010-11/winsockio/" class="article-date">
  	<time datetime="2010-11-20T16:00:00.000Z" itemprop="datePublished">2010-11-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Windows Socket IO 模型
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/">socket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows/">windows</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/develop/">develop</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="套接字架构"><a href="#套接字架构" class="headerlink" title="套接字架构"></a>套接字架构</h2><hr>
<p><p align="center"><img src="http://dn-huangweipro.qbox.me/static/img/winsock1.gif" alt="图1"></p></p>
<p>应用程序使用Winsock与传输协议驱动沟通时AFD.SYS负责缓冲区的管理。这就意味着当一个程序调用send或者WSASend发送数据时，数据将被复制到AFD.SYS它自己的内部缓冲区中（依赖SO_SNDBUF的设置）WSASend调用立即返回。然后AFD.SYS在程序后台将数据发送出去。当然，如果程序想要处理一个比SO_SNDBUF设置的缓冲区需求更大的发送请求，WSASend的调用就会阻塞直到所有的数据都被发送出去。</p>
<p>类似的，从远程客户端接收数据时，只要SO_RCVBUF设置的缓冲区还没有满，AFD.SYS就会将数据复制进它自己的缓冲区直到所有的发送都已完成。当程序调用recv或者是WSARecv，数据就从AFD.SYS的缓冲区复制到了程序提供的缓冲区中了。</p>
<a id="more"></a>
<p>使用Winsock的时候还会间接碰到另外两种资源的限制。第一个页面锁定的限制。注意重叠操作可能偶然性地以ERROR_INSUFFICIENT_RESOURCES调用失败，这基本上意味着有太多的发送和接收操作在等待中。另外一个限制是操作系统的非分页池（non-paged pool）的限制。</p>
<h3 id="阻塞模型"><a href="#阻塞模型" class="headerlink" title="阻塞模型"></a>阻塞模型</h3><table><br><tr><br><td><br><br><pre class="prettyprint lang-cpp"><br>int recv(<br>SOCKET s,<br>char<em> buf,<br>int len,<br>int flags<br>);<br></em></pre><br><br></td><br><td><br><br><pre class="prettyprint lang-cpp"><br>int send(<br>SOCKET s,<br>const char buf,<br>int len,<br>int flags<br>);<br></pre><br><br></td><br></tr><br></table>


<p>这种方式最为大家熟悉，Socket默认的就是阻塞模式。</p>
<p>在recv的时候，Socket会阻塞在那里，直到连接上有数据可读，把数据读到buffer里后recv函数才会返回，不然就会一直阻塞在那里。</p>
<p>如果在主线程中被阻塞，而数据迟迟没有过来，那么程序就会被锁死。这样的问题可以用多线程解决，但是在有多个套接字连接的情况下，这不是一个好的选择，扩展性很差，而且也容易有锁的问题。线程过多，也导致上下文切换过于频繁，导致系统变慢，而且大部分线程是处于非活动状态的话，这就大大浪费了系统的资源。</p>
<h3 id="非阻塞模型"><a href="#非阻塞模型" class="headerlink" title="非阻塞模型"></a>非阻塞模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctlsocket</span><span class="params">(</span><br><span class="line">IN SOCKET s,</span><br><span class="line">IN <span class="keyword">long</span> cmd,</span><br><span class="line">IN OUT u_long FAR * argp</span><br><span class="line">)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIONBIO <span class="comment">/* set/clear non-blocking i/o */</span></span></span><br></pre></td></tr></table></figure>
<p>调用ioctlsocket函数设置FIONBIO为1就转为非阻塞模式。</p>
<p>当recv和send函数没有准备好数据时，函数不会阻塞，立即返回错误值，用GetLastError返回的错误码为WSAEWOULDBLOCK，中文解释为“无法立即完成一个非阻挡性套接字的操作”。</p>
<p>当然，这里你可以用非阻塞模拟阻塞模式，就是用while循环不停调用recv，直到recv返回成功为止。这样的效率也不高，但好处在于你能在没接收到数据时，有空进行其他操作，或者直接Sleep。</p>
<h3 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span><br><span class="line"><span class="keyword">int</span> nfds,</span><br><span class="line">fd_set* readfds,</span><br><span class="line">fd_set* writefds,</span><br><span class="line">fd_set* exceptfds,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> timeval* timeout</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Select模型是非阻塞的，函数内部自动检测WSAEWOULDBLOCK状态，还能有超时设定。对read，write，except三种事件进行分别检测，except指带外数据可读取，read和write的定义是广义的，accept，close等消息也纳入到read。</p>
<p>Select函数使用fd_set结构，它的结构非常的简单，只有一个数组和计数器。<br>Timeval结构里可以设置超时的时间。</p>
<p>Select函数返回值表示集合中有事件触发的sock总数，其余操作使用fd_set的宏来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE      64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* FD_SETSIZE */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> fd_set &#123;</span><br><span class="line">u_int fd_count;               <span class="comment">/* how many are SET? */</span></span><br><span class="line">SOCKET  fd_array[FD_SETSIZE];   <span class="comment">/* an array of SOCKETs */</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line">FD_CLR(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_ISSET(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_SET(s, *<span class="built_in">set</span>)</span><br><span class="line">FD_ZERO(*<span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
<p>Select模型流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd_set fdread;</span><br><span class="line">timeval tv = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化fd_set</span></span><br><span class="line">    FD_ZERO(&amp;fdread);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nSock; i ++)</span><br><span class="line">        FD_SET(socks[i], &amp;fdread);</span><br><span class="line">    <span class="comment">// 等待事件触发，或超时返回</span></span><br><span class="line">    <span class="keyword">int</span> ret = select(<span class="number">0</span>, &amp;fdread, NULL, NULL, &amp;tv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ret &gt; <span class="number">0</span> &amp;&amp; i &lt; nSock; i ++)</span><br><span class="line">        <span class="comment">// 检测哪个sock有事件触发</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(socks[i], &amp;fdread)) &#123;</span><br><span class="line">            read_buf(socks[i]);</span><br><span class="line">            ret --;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实select的原理就是对sock集合进行扫描，有事件或者超时则退出，所以select的效率也是和sock数量成线性关系，而且需要我们自己循环检查哪个sock有事件发生。</p>
<p>它的优点是模型简单，过程清晰，容易管理，支持多个sock服务。缺点也很明显，本质还是个循环的改进版本，而且fd_set里最多只能放64个sock，还有它无法很好的支持sock事件的先后顺序。</p>
<h3 id="WSAAsynSelect模型"><a href="#WSAAsynSelect模型" class="headerlink" title="WSAAsynSelect模型"></a>WSAAsynSelect模型</h3><p>WSAAsynSelect是Windows特有的，可以在一个套接字上接收以Windows消息为基础的网络事件通知。该模型的实现方法是通过调用WSAAsynSelect函数自动将套接字设置（转变）为非阻塞模式，并向Windows注册一个或多个网络事件lEvent，并提供一个通知时使用的窗口句柄hWnd。当注册的事件发生时，对应的窗口将收到一个基于消息的通知wMsg。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAAsyncSelect</span><span class="params">(</span><br><span class="line">SOCKET s,</span><br><span class="line">HWND hWnd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> wMsg,</span><br><span class="line"><span class="keyword">long</span> lEvent</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>WSAAsyncSelect模型流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_SOCKET WM_USER+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hINstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">    SOCKET Listen;</span><br><span class="line">    HWND Window;</span><br><span class="line">    <span class="comment">// 创建窗口，绑定上WinProc</span></span><br><span class="line">    <span class="comment">// 创建sock</span></span><br><span class="line">    WSAStartup(…);</span><br><span class="line">    Listen = Socket();</span><br><span class="line">    bind(…);</span><br><span class="line">    WSAAsyscSelect(Listen, Window, WM_SOCKET, FD_ACCEPT | FD_CLOSE);</span><br><span class="line">    listen(Listen, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">WinProc</span><span class="params">(HWND hDlg, WORD wMsg, WORD wParam, DWORD lParam)</span> </span>&#123;</span><br><span class="line">    SOCKET Accept;</span><br><span class="line">    <span class="keyword">switch</span>(wMsg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_SOCKET:</span><br><span class="line">        <span class="comment">// lParam的高字节包含了可能出现的任何的错误代码</span></span><br><span class="line">        <span class="comment">// lParam的低字节指定已经发生的网络事件</span></span><br><span class="line">        <span class="comment">// 发生错误</span></span><br><span class="line">        <span class="keyword">if</span>(WSAGETSELECTERROR(lParam)) &#123;</span><br><span class="line">            closesocket…</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 事件触发</span></span><br><span class="line">        <span class="keyword">switch</span>( WSAGETSELECTEVENT(lParam) ) &#123;</span><br><span class="line">            <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">            <span class="keyword">case</span> FD_READ:</span><br><span class="line">            <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WSAAsyncSelect是模仿Windows消息机制来实现的，使用起来很方便，仅仅只是在消息处理中加入了对WM_SOCKET的处理，这样就能严格得按先后顺序处理sock事件。</p>
<p>MFC中的CSOCKET也采用了这个模型。</p>
<p>lEvent事件表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Event</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FD_READ</td>
<td style="text-align:left">应用程序想要接收有关是否可读的通知，以便读入数据</td>
</tr>
<tr>
<td style="text-align:left">FD_WRITE</td>
<td style="text-align:left">应用程序想要接收有关是否可写的通知，以便写入数据</td>
</tr>
<tr>
<td style="text-align:left">FD_OOB</td>
<td style="text-align:left">应用程序想接收是否有带外（OOB）数据抵达的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_ACCEPT</td>
<td style="text-align:left">应用程序想接收与进入连接有关的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_CONNECT</td>
<td style="text-align:left">应用程序想接收与一次连接或者多点join操作完成的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_CLOSE</td>
<td style="text-align:left">应用程序想接收与套接字关闭有关的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_QOS</td>
<td style="text-align:left">应用程序想接收套接字“服务质量”（QoS）发生更改的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_GROUP_QOS</td>
<td style="text-align:left">应用程序想接收套接字组“服务质量”发生更改的通知（现在没什么用处，为未来套接字组的使用保留）</td>
</tr>
<tr>
<td style="text-align:left">FD_ROUTING_INTERFACE_CHANGE</td>
<td style="text-align:left">应用程序想接收在指定的方向上，与路由接口发生变化的通知</td>
</tr>
<tr>
<td style="text-align:left">FD_ADDRESS_LIST_CHANGE</td>
<td style="text-align:left">应用程序想接收针对套接字的协议家族，本地地址列表发生变化的通知</td>
</tr>
</tbody>
</table>
<p>只有在以下3种条件下，会发送FD_WRITE事件：</p>
<ul>
<li>使用connect。连接首次被建立。</li>
<li>使用accept。套接字被接受。</li>
<li>使用send，sendto。</li>
</ul>
<p>它的缺点就是，每个sock事件处理需要一个窗口句柄，如果sock很多的情况下，资源和性能可想而知了。</p>
<h3 id="WSAEventSelect模型"><a href="#WSAEventSelect模型" class="headerlink" title="WSAEventSelect模型"></a>WSAEventSelect模型</h3><p>WSAEventSelect模型类似WSAAsynSelect模型，但最主要的区别是网络事件发生时会被发送到一个Event对象句柄，而不是发送到一个窗口。这样你就可以使用Event对象的特性了。但WSAEventSelect模型明显复杂很多。</p>
<p>它需要由以下函数一起完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建事件对象来接收网络事件：</span></span><br><span class="line"><span class="function">WSAEVENT <span class="title">WSACreateEvent</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="comment">// 2. 将事件对象与套接字关联，同时注册事件，使事件对象的工作状态从未传信转变未已传信。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAEventSelect</span><span class="params">( SOCKET s,WSAEVENT hEventObject,<span class="keyword">long</span> lNetworkEvents )</span></span>;</span><br><span class="line"><span class="comment">// 3. I/O处理后，设置事件对象为未传信</span></span><br><span class="line"><span class="function">BOOL <span class="title">WSAResetEvent</span><span class="params">( WSAEVENT hEvent )</span></span>;</span><br><span class="line"><span class="comment">// 4. 等待网络事件来触发事件句柄的工作状态：</span></span><br><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">( DWORD cEvents,<span class="keyword">const</span> WSAEVENT FAR * lphEvents, BOOL fWaitAll,DWORD dwTimeout, BOOLfAlertable )</span></span>;</span><br><span class="line"><span class="comment">// 5.  获取网络事件类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAEnumNetworkEvents</span><span class="params">( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents )</span></span>;</span><br></pre></td></tr></table></figure>
<p>WSACreateEvent其实跟CreateEvent的效果类似，返回的WSAEVENT类型其实就是HANDLE类型，所以可以直接使用CreateEvent创建特殊的Event。</p>
<p>sock和Event对象是对应的，当一个套接字有事件发生，WSAWaitForMultipleEvents返回相应的值，通过这个值来索引这个套接字。 但它也和select一样，在Event数组大小上也有限制，MAXIMUM_WAIT_OBJECTS的值为64。</p>
<p>有了Event对象的支持，signaled/non-signaled和manual reset/auto reset的概念也就可以应用到程序里，这样能使sock事件处理的方式比较丰富灵活。而且它也能严格按先后顺序处理sock事件。</p>
<p>闪电邮PushMail的处理就是WSAEventSelect模型。</p>
<h3 id="Over-Lapped-IO模型"><a href="#Over-Lapped-IO模型" class="headerlink" title="Over-Lapped IO模型"></a>Over-Lapped IO模型</h3><p>它和之前模型不同的是，使用重叠模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。之前的模型都是在套接字的缓冲区中，当通知应用程序接收后，在把数据拷贝到程序的缓冲区。</p>
<p>这种模型适用于除WindowsCE外的其他Windows平台，该模型是以Windows的重叠IO机制为基础，通过ReadFile和WriteFile，针对设备执行IO操作。</p>
<p>早先这种机制是用于文件IO，在Socket IO和文件IO统一接口之后，这种机制也被引入Socket IO。但这类模型的实现就相对复杂多了。</p>
<p>有两个方法可以实现重叠IO请求的完成情况（接到重叠操作完成的通知）：</p>
<ul>
<li>事件对象通知（event object notification）。</li>
<li>完成例程（completion routines）。注意，这里并不是完成端口。</li>
</ul>
<h4 id="WSAOVERLAPPED"><a href="#WSAOVERLAPPED" class="headerlink" title="WSAOVERLAPPED"></a>WSAOVERLAPPED</h4><p>重叠结构是不得不提的，之后的完成端口模型也需要用到。这个结构等同于OVERLAPPED。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _WSAOVERLAPPED &#123;</span><br><span class="line">DWORD Internal;</span><br><span class="line">DWORD InternalHigh;</span><br><span class="line">DWORD Offset;</span><br><span class="line">DWORD OffsetHigh;</span><br><span class="line">WSAEVENT hEvent; <span class="comment">// 只关注这个参数，用来关联WSAEvent对象</span></span><br><span class="line">&#125; WSAOVERLAPPED, *LPWSAOVERLAPPED;</span><br></pre></td></tr></table></figure>
<p>使用重叠结构，我们常用的send, sendto, recv, recvfrom也都要被WSASend, WSASendto, WSARecv, WSARecvFrom替换掉了，是因为它们的参数中都有一个Overlapped参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSARecv</span><span class="params">(</span><br><span class="line">SOCKET s, <span class="comment">// [in] 套接字</span></span><br><span class="line">LPWSABUF lpBuffers, <span class="comment">// [in,out] 接收缓冲区，WSABUF的数组</span></span><br><span class="line">DWORD dwBufferCount, <span class="comment">// [in] 数组中WSABUF的数量</span></span><br><span class="line">LPDWORD lpNumberOfBytesRecvd, <span class="comment">// [out] 此刻函数所接收到的字节数</span></span><br><span class="line">LPDWORD lpFlags,             <span class="comment">// [in,out] 这里设置为0 即可</span></span><br><span class="line">LPWSAOVERLAPPED lpOverlapped,  <span class="comment">// [in] 绑定重叠结构</span></span><br><span class="line">LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span><br><span class="line"><span class="comment">// [in] 完成例程中将会用到的参数</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>没有错误且收取立刻完成时，返回值为0，否则是SOCKET_ERROR。常见的错误码是WSA_IO_PENDING，表示重叠操作正在进行。相应的其他函数也是类似参数，具体参考MDSN。</p>
<p>获取重叠操作的结果，由WSAWaitForMultipleEvents函数来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WSAGetOverlappedResult</span><span class="params">(</span><br><span class="line">SOCKET s, <span class="comment">// [in] 套接字</span></span><br><span class="line">LPWSAOVERLAPPED lpOverlapped, <span class="comment">// [in] 要查询的重叠结构的指针</span></span><br><span class="line">LPDWORD lpcbTransfer,<span class="comment">// [out] 本次重叠操作的实际接收(或发送)的字节数</span></span><br><span class="line">BOOL fWait, <span class="comment">// [in] 设置为TRUE，除非重叠操作完成，否则函数不会返回</span></span><br><span class="line"><span class="comment">// 设置FALSE，而且操作仍处于挂起状态，那么函数就会返回FALSE，错误为WSA_IO_INCOMPLETE</span></span><br><span class="line">LPDWORD lpdwFlags <span class="comment">// [out] 负责接收结果标志</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h4><p>事件等待函数和WaitForMultipleObjects类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">(</span><br><span class="line">DWORD cEvents, <span class="comment">// [in] 等候事件的总数量</span></span><br><span class="line"><span class="keyword">const</span> WSAEVENT* lphEvents, <span class="comment">// [in] 事件数组的指针</span></span><br><span class="line">BOOL fWaitAll, <span class="comment">// [in] 是否等待所有事件</span></span><br><span class="line">DWORD dwTimeout, <span class="comment">// [in] 超时时间</span></span><br><span class="line">BOOL fAlertable <span class="comment">// [in] 在完成例程中会用到这个参数</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值有这么几个：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>WSA_WAIT_TIMEOUT</td>
<td>超时，我们要继续Wait</td>
</tr>
<tr>
<td>WSA_WAIT_FAILED</td>
<td>出现错误</td>
</tr>
<tr>
<td>WAIT_IO_COMPLETION</td>
<td>一个或多个完成例程入队列执行</td>
</tr>
<tr>
<td>WSA_WAIT_EVENT_0 ~ (WSA_WAIT_EVENT_0 + cEvents – 1)</td>
<td>触发的事件下标</td>
</tr>
</tbody>
</table>
<p>事件通知的重叠IO模型大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立并初始化buf和overlap</span></span><br><span class="line">WSAOVERLAPPED Overlap;</span><br><span class="line">WSABUF DataBuf;</span><br><span class="line"><span class="keyword">char</span>* SendBuf = new <span class="keyword">char</span>[BufLen];</span><br><span class="line">DWORD Flags = <span class="number">0</span>;</span><br><span class="line">DataBuf.len = BufLen;</span><br><span class="line">DataBuf.buf = SendBuf;</span><br><span class="line">Overlap.hEvent = EventArray[dwEventTotal ++] = WSACreateEvent();</span><br><span class="line"><span class="comment">// 2. 在套接字上投递WSARecv请求</span></span><br><span class="line"><span class="keyword">int</span> ret = WSARecv(Sock, &amp;DataBuf, <span class="number">1</span>, &amp;NumberOfBytesRecvd,</span><br><span class="line">&amp;Flags, &amp;Overlap, NULL);</span><br><span class="line"><span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING)</span><br><span class="line">error_handle(…);</span><br><span class="line"><span class="comment">// 3. 等待事件通知</span></span><br><span class="line">DWORD dwIndex = WSAWaitForMultipleEvents(dwEventTotal,EventArray,     FALSE, WSA_INFINITE, FALSE);</span><br><span class="line"><span class="keyword">if</span> (dwIndex == WSA_WAIT_FAILED || dwIndex == WSA_WAIT_TIMEOUT)</span><br><span class="line">error_handle(…);</span><br><span class="line">dwIndex -= WSA_WAIT_EVENT_0;</span><br><span class="line"><span class="comment">// 4. 重置事件对象</span></span><br><span class="line">WSAResetEvent(EventArray[dwIndex]);</span><br><span class="line"><span class="comment">// 5. 取得重叠调用的返回状态</span></span><br><span class="line">DWORD dwBytesTransferred;</span><br><span class="line">WSAGetOverlappedResult(Sock, Overlap, &amp;dwBytesTransferred, TRUE, &amp;Flags);</span><br><span class="line"><span class="keyword">if</span> (dwBytesTransferred == <span class="number">0</span>)</span><br><span class="line">closesocket(Sock);</span><br><span class="line">dosomething(…);</span><br></pre></td></tr></table></figure>
<p>如果是服务端使用事件通知模型，则需要再起一个线程来循环Wait事件通知，主线程则接受请求的连接。</p>
<p>实际编码过程中，要注意缓冲区不要搞错，因为全都需要自己来管理，稍有不慎就容易写脏数据和越界。还要注意WSARecv时，可能立即有数据返回的情况，即返回值为0且NumberOfBytesRecvd &gt; 0。</p>
<h4 id="完成例程"><a href="#完成例程" class="headerlink" title="完成例程"></a>完成例程</h4><p>完成例程（Completion Routine），不是完成端口。它是使用APC（Asynchronous Procedure Calls）异步回调函数来实现，大致流程和事件通知模型差不多，只不过WSARecv注册时，加上了lpCompletionRoutine参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void CALLBACK <span class="title">CompletionROUTINE</span><span class="params">(</span><br><span class="line">DWORD dwError, <span class="comment">// [in] 标志咱们投递的重叠操作完成的状态</span></span><br><span class="line">DWORD cbTransferred, <span class="comment">// [in] 重叠操作期间，实际传输的字节量是多大</span></span><br><span class="line">LPWSAOVERLAPPED lpOverlapped, <span class="comment">// [in] 传递到最初IO调用的重叠结构</span></span><br><span class="line">DWORD dwFlags  <span class="comment">// [in] 返回操作结束时可能用的标志(一般没用)</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但完成例程有一个比较隐晦的地方，就是APC机制本身。</p>
<h5 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h5><p>ReadFileEx / WriteFileEx在发出IO请求的同时，提供一个回调函数（APC过程），当IO请求完成后，一旦线程进入可告警状态，回调函数将会执行。</p>
<p>以下五个函数能够使线程进入告警状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SleepEx</span><br><span class="line">WaitForSingleObjectEx</span><br><span class="line">WaitForMultipleObjectsEx</span><br><span class="line">SignalObjectAndWait</span><br><span class="line">MsgWaitForMultipleObjectsEx</span><br></pre></td></tr></table></figure>
<p>线程进入告警状态时，内核将会检查线程的APC队列，如果队列中有APC，将会按FIFO方式依次执行。如果队列为空，线程将会挂起等待事件对象。以后的某个时刻，一旦APC进入队列，线程将会被唤醒执行APC，同时等待函数返回WAIT_IO_COMPLETION。</p>
<p><p align="center"><img src="http://dn-huangweipro.qbox.me/static/img/winsock2.jpg" alt="图2"></p></p>
<p>回到完成例程的话题上。</p>
<p>需要一个辅助线程，辅助线程的工作是判断有没有新的客户端连接被建立，如果有，就为那个客户端套接字激活一个异步的WSARecv操作，然后调用SleepEx使线程处于一种可警告的等待状态，以使得I/O完成后 CompletionROUTINE可以被内核调用，而CompletionROUTINE会在当初激活WSARecv异步操作的代码的同一个线程之内！而且调用SleepEx时，需要把bAlertable参数设为TRUE，这样当有APC唤醒时立即调用完成例程，否则例程就不会被执行。当然也可以使用WSAWaitForMultipleEvents函数，但这样就需要一个事件对象。</p>
<p>从图中就能看到CompletionROUTINE是在辅助线程（调用过WSARecv）里执行的。</p>
<h3 id="Completion-Port模型"><a href="#Completion-Port模型" class="headerlink" title="Completion Port模型"></a>Completion Port模型</h3><p>“完成端口”模型是迄今为止最为复杂的一种I/O模型。</p>
<p>假若一个应用程序同时需要管理为数众多的套接字，那么采用这种模型，往往可以达到最佳的系统性能！它能最大限度的减少上下文切换的同时最大限度的提高系统并发量。但不幸的是，该模型只适用于Windows NT和Windows 2000操作系统。</p>
<p>因其设计的复杂性，只有在你的应用程序需要同时管理数百乃至上千个套接字的时候，而且希望随着系统内安装的CPU数量的增多，应用程序的性能也可以线性提升，才应考虑采用“完成端口”模型。</p>
<p>要记住的一个基本准则是，假如要为Windows NT或Windows 2000开发高性能的服务器应用，同时希望为大量套接字I/O请求提供服务（Web服务器便是这方面的典型例子），那么I/O完成端口模型便是最佳选择！</p>
<p>完成端口是一种WINDOWS内核对象。完成端口用于异步方式的重叠I/O。简单地，可以把完成端口看成系统维护的一个队列，操作系统把重叠IO操作完成的事件通知放到该队列里，由于是暴露 “操作完成”的事件通知，所以命名为“完成端口”（Completion Ports）。</p>
<p>完成端口内部提供了线程池的管理，可以避免反复创建线程的开销，同时可以根据CPU的个数灵活的决定线程个数，而且可以让减少线程调度的次数从而提高性能。</p>
<p><p align="center"><img src="http://dn-huangweipro.qbox.me/static/img/winsock3.gif" alt="图3"></p></p>
<p>它需要以下函数的支持，CreateIoCompletionPort函数用于创建和绑定完成端口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateIoCompletionPort</span><span class="params">(</span><br><span class="line">HANDLE FileHandle, <span class="comment">// [in] IO句柄对象，这里是套接字</span></span><br><span class="line">HANDLE ExistingCompletionPort, <span class="comment">// [in] 完成端口</span></span><br><span class="line">ULONG_PTR CompletionKey, <span class="comment">// [in] 自定义数据指针</span></span><br><span class="line">DWORD NumberOfConcurrentThreads <span class="comment">// [in] 最大线程数，0为自动</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们还需要类似WSAGetOverlappedResult的函数来获取完成端口的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span><br><span class="line">HANDLE CompletionPort, <span class="comment">// [in] 完成端口</span></span><br><span class="line">LPDWORD lpNumberOfBytes, <span class="comment">// [out] 此次IO操作的字节数</span></span><br><span class="line">PULONG_PTR lpCompletionKey, <span class="comment">// [out] 自定义数据指针，CreateIoCompletionPort初始化的</span></span><br><span class="line">LPOVERLAPPED* lpOverlapped, <span class="comment">// [out] 投递请求时的重叠结构指针</span></span><br><span class="line">DWORD dwMilliseconds <span class="comment">// [in] 超时设置</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>还有PostQueuedCompletionStatus函数，能模拟一个完成的重叠I/O操作。我们可以当成类似PostMessage的函数，以此控制工作线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostQueuedCompletionStatus</span><span class="params">(</span><br><span class="line">HANDLE CompletionPort, <span class="comment">// [in] 完成端口</span></span><br><span class="line">DWORD dwNumberOfBytesTransferred, <span class="comment">// [in] 此次IO操作的字节数</span></span><br><span class="line">ULONG_PTR dwCompletionKey, <span class="comment">// [in] 自定义数据指针</span></span><br><span class="line">LPOVERLAPPED lpOverlapped <span class="comment">// [in] 重叠结构指针</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>完成端口模型大致流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 参数设空，就能创建完成端口</span></span><br><span class="line">HANDLE CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,NULL,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 创建工作线程</span></span><br><span class="line">DWORD dwThreadId;</span><br><span class="line">SYSTEM_INFO sysinfo;</span><br><span class="line">GetSystemInfo(&amp;sysinfo);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sysinfo.dwNumberOfProcessors; i++)</span><br><span class="line">    CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, iocp_work_thread, CompletionPort, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"><span class="comment">// 3. 建立并初始化buf和overlap（参照重叠IO）</span></span><br><span class="line"><span class="comment">// 4. 将套接字绑定到完成端口</span></span><br><span class="line">CreateIoCompletionPort((HANDLE)Sock,CompletionPort,Sock,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 5. 在套接字上投递WSARecv请求（参照重叠IO）</span></span><br><span class="line"><span class="comment">// 6. 在工作线程中取本次I/O的相关信息</span></span><br><span class="line">GetQueuedCompletionStatus(CompletionPort,&amp;dwBytesTransferred,</span><br><span class="line">(DWORD*)&amp;Sock,(LPOVERLAPPED*)&amp;lpPerIOData,INFINITE);</span><br><span class="line"><span class="keyword">if</span> (dwBytesTransferred == <span class="number">0</span>)</span><br><span class="line">    closesocket(Sock);</span><br><span class="line">dosomething(…);</span><br></pre></td></tr></table></figure>
<h2 id="测试图例"><a href="#测试图例" class="headerlink" title="测试图例"></a>测试图例</h2><hr>
<p>来自于《Windows网络编程》的数据。</p>
<p><p align="center"><img src="http://dn-huangweipro.qbox.me/static/img/winsock4.jpg" alt="图4"></p></p>
<p>阻塞模型难以应对大规模的客户连接，因为它在创建线程上耗费了太多的系统资源。因此，服务器创建太多的线程后，再调用CreateThread函数时，将返回ERROR_NOT_ENOUGH_MEMORY的错误，那些发出连接请求的客户则收到WSAECONNREFUSED的错误提示，表示连接的尝试被拒绝。其并发处理量是极难突破的。</p>
<p>非阻塞模型和Select模型的性能要比阻塞模式稍好，但是占用了太多的CPU处理时间。瓶颈在于，fd_set集合的线性扫描上。还需要注意的一个问题就是，非分页池（即直接在物理内存中分配的内存）的使用极高。这是因为AFD（Ancillary Function Driver,由afd.sys提供的支持Windows Sockets应用程序的底层驱动程序，其中运行在内核模式下afd.sys驱动程序主要管理Winsock TCP/IP通信）和TCP都将使用I/O缓存，因为服务器读取数据的速度是有限的，相对于CPU的处理速度而言，I/O基本是零字节的吞吐量。</p>
<p>基于Windows消息机制的WSAAsyncSelect模型能够处理一定的客户连接量，但是扩展性也不是很好。因为消息泵很快就会阻塞，降低了消息处理的速度。在几次测试中，服务器只能处理大约1/3的客户端连接。过多的客户端连接请求都将返回错误提示码WSAECONNREFUSED。上表中的数据可以发现，对那些已经建立的连接，其平均吞吐量也是极低的。</p>
<p>基于事件通知的WSAEventSelect模型表现得出奇的不错。在所有的测试中，大多数时候，服务器基本能够处理所有的客户连接，并且保持着较高的数据吞吐量。这种模型的缺点是，每当有一个新连接时，需要动态管理线程池，因为每个线程只能够等待64个事件对象。但最后，服务器不能再接受更多的连接，原因是WSAENOBUFS（无可用的缓冲区空间），套接字无法创建。另外，客户端程序也达到了极限，不能维持已经建立的连接。</p>
<p>事件通知的重叠I/O模型和WSAEventSelect模型在伸缩性上差不多。这两种模型都依赖于等待事件通知的线程池，处理客户通信时，大量线程上下文的切换是它们共同的制约因素。重叠I/O模型和WSAEventSelect模型的测试结果很相似，都表现得不错，直到线程数量超过极限。</p>
<p>例程通知的重叠I/O模型，性能和事件通知的重叠I/O模型相同，但因为以下几个原因，也不是开发高性能服务器的最佳选择。首先，许多扩展功能不允许使用APC完成通知。其次，由于APC在系统内部特有的处理机制，应用程序线程可能无限等待而得不到完成通知。当一个线程处于“可警告状态”时，所有挂起的APC按照先进先出的顺序（FIFO）接受处理。</p>
<p>完成端口模型的是所有I/O模型中性能最佳的。内存使用率（包括用户分页池和非分页池）基本差不多。真正不同的地方，在于对CPU的占用。完成端口模型只占用了60%的CPU，但是在维持同样规模的连接量时，另外两种模型（基于事件通知的重叠I/O模型和WSAEventSelect模型）占用更多的CPU。完成端口的另外一个明显的优势是，它维持更大的吞吐量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<h3 id="客户端的选择"><a href="#客户端的选择" class="headerlink" title="客户端的选择"></a>客户端的选择</h3><p>为了能在一定程度上提升性能，建议使用重叠IO模型或者WSAEventSelect模型。</p>
<p>如果是窗口程序，且socket不多的情况下，可以使用WSAAsyncSelect模型。</p>
<p>当然，如果性能啥的都不需要考虑的，那简洁的Select模式值得被考虑。</p>
<h3 id="服务端的选择"><a href="#服务端的选择" class="headerlink" title="服务端的选择"></a>服务端的选择</h3><p>既然是服务端，必然要需要性能不错的。</p>
<p>重叠IO模型可以使你在给定的时间段内同时控制多个套接字。</p>
<p>但是，如果服务器在任意时间里都有大量IO请求，那就用完成端口模型。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li>Windows核心编程;</li>
<li>手把手教你玩转SOCKET模型之重叠I/O篇;<br><a href="http://dev.csdn.net/htmls/39/39122.html" target="_blank" rel="external">http://dev.csdn.net/htmls/39/39122.html</a></li>
<li>手把手教你玩转网络编程模型之完成例程(Completion Routine)篇;<br><a href="http://blog.csdn.net/PiggyXP/archive/2009/02/19/3910726.aspx" target="_blank" rel="external">http://blog.csdn.net/PiggyXP/archive/2009/02/19/3910726.aspx</a></li>
<li>Windows Sockets 2.0: Write Scalable Winsock Apps Using Completion Ports;<a href="http://msdn.microsoft.com/zh-cn/magazine/cc302334(en-us" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/magazine/cc302334(en-us).aspx</a>.aspx)</li>
<li>Inside I/O Completion Ports;<a href="http://hi.baidu.com/jrckkyy/blog/item/401422527c131b070df3e37b.html" target="_blank" rel="external">http://hi.baidu.com/jrckkyy/blog/item/401422527c131b070df3e37b.html</a></li>
<li>Windows 2000 非分页池被 Afd.sys 耗尽;<a href="http://support.microsoft.com/kb/296265/zh-cn" target="_blank" rel="external">http://support.microsoft.com/kb/296265/zh-cn</a></li>
<li>WinSock五种I/O模型的性能分析;<a href="http://www.rover12421.com/2010/04/02/winsock%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html" target="_blank" rel="external">http://www.rover12421.com/2010/04/02/winsock%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html</a></li>
</ol>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2012-09/baidu-suggestion/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          百度面试题 - 搜索框的suggestion
        
      </div>
    </a>
  
  
    <a href="/2010-11/bloomfilter/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Bloom Filter 原理与应用</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2010-11/winsockio/" data-title="Windows Socket IO 模型" data-url="http://huangwei.pro/2010-11/winsockio/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"huangweipro"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 HuangWei
    	</div>
      	<div class="footer-right">
    <a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=cd675bc111a203d3ae8b7f069037bf1cb3127d6d6d431851d7acbbbe76d3962c"><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="游戏开发者俱乐部" title="游戏开发者俱乐部"></a>
		<script src="http://s4.cnzz.com/z_stat.php?id=1257126202&web_id=1257126202" language="JavaScript"></script>
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		cdn: 'http://dn-huangweipro.qbox.me/'
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="http://dn-huangweipro.qbox.me/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-58636572-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<!-- Baidu Analytics -->
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?37eed26af63c8a627a52667cb97cf2cf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
<!-- End Baidu Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
